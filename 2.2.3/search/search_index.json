{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Before to start","text":"<ul> <li> <p>If you don't know anything about glacier processes, explore this great website. If you don't know anything about glacier evolution modeling, you may watch first this video, which gives some basics. </p> </li> <li> <p>OS: IGM was developed in a Linux environment but works on Windows and Mac. Windows user are strongly recommended to use WSL2 for using the GPU and the OGGM shop module. </p> </li> <li> <p>Disclaimer: IGM implements empirical physical laws, with an important amount of approximations (of any kind). Make sure to understand what you do, to explore key parameters, and interpret the results with care.</p> </li> </ul>"},{"location":"#how-to-start","title":"How to start","text":"<p>Running IGM consists of running a python script <code>igm_run</code>, which is made of functions of the IGM python package. This documentation will help you to understand the parameters and, set-up your model by listing the modules you need, customize your own modules for your application.</p> <ul> <li> <p>First, start with the 10-min video tutorial, or a longer IGS seminar presentation, and/or look at the in-progress IGM technical paper.</p> </li> <li> <p>Then, install an igm python environment on your system and starting with examples.</p> </li> <li> <p>Then, learn how to run IGM with module list and parameter setting (without extra coding), and explore the module documentation.</p> </li> <li> <p>Last, understand the code and write your own module code. </p> </li> </ul>"},{"location":"FAQ/","title":"FAQ","text":"<ul> <li>Ice is stuck on the border of the domain (no fluxes), what can I do?</li> </ul> <p>Set parameter exclude_borders_from_iceflow to True</p> <ul> <li>I see some numerical artifacts (e.g. waves) occurring when modeling glacier evolution, what can I do?</li> </ul> <p>Reduce the CFL parameter</p> <ul> <li>How to create/modify NetCDF files?</li> </ul> <p>There are many ways to prepare NetCDF files (matlab, python, GIS tools, ...). The NCO toolkit permits easy operations in command lines, e.g.</p> <pre><code>   ncks -x -v thk file.nc file.nc              # this removes the variable 'thk' from file.nc\n   ncks -v usurf file.nc file.nc               # this extracts the variable usurf from file.nc\n   ncap2 -h -O -s 'thk=0*thk' file.nc file.nc  # this does operations on file.nc, here force zero thk\n   ncrename -v apc,strflowctrl file.nc         # this renames varible apc to strflowctrl in file.nc\n</code></pre> <ul> <li>oggm_shop produces error on windows</li> </ul> <p>This is expected, OGGM is not supported on windows, however, modifying the tarfile.py file at line 2677 from name == member_name to name.replace(os.sep, '/') == member_name seems to fix the issue on Windows. Thanks Alexi Morin for proposing this workaround.</p>"},{"location":"Installation/","title":"Installation","text":"<p>IGM is a Python package, which works on any OS on </p> <ul> <li>CPU (not computationally efficient, but fine for small applications like individual glaciers),</li> <li>GPU (the most computationally efficient way, especially relevant for large-scale and high-resolution applications). </li> </ul> <p>IGM can be installed with the </p> <ul> <li>the main version for stable application (the latest available tag), not all modules,</li> <li>the development version to get the latest feature with all modules (at the possible price of unrevealed bugs). </li> </ul> <p>Both versions are now on the same (main) branch. IGM is rapidly changing, keep track of updates on the release page for the tagged versions or/and on this page for the development version.</p> <p>Note that the igm package installs most of dependent packages, but not all. For using some post-processing modules, the user has to install additional packages (e.g., mayavi, plotly, ect.).</p> <p>We first describe the installation in Linux (the preferred OS), and then on Windows and Mac.</p>"},{"location":"Installation/#linux","title":"Linux","text":""},{"location":"Installation/#windows","title":"Windows","text":""},{"location":"Installation/#mac","title":"Mac","text":""},{"location":"Installation/#troubleshooting","title":"Troubleshooting","text":"<p>Main source of issues are linked to Tensorflow and the use of GPU. Hopefully, the installation is significantly easier since tensorflow 2.14.0 since it can install all necessary GPU/cuda dependent packages with the right version automatically. Note that to ensure smooth usage of GPU with cuda and tensorflow libraries, one has to make sure that i) cuda ii) cudnn iii) tensorflow are compatible, and your Nvidia driver is compatible with the version of cuda. Such incompatibility is the most common source of issue. </p> <p>For instance, it is possible do install tensorflow-2.12.0 by setting <code>tensorflow==2.12.0</code> in the setup.py and</p> <pre><code>conda install -c conda-forge cudatoolkit=11.8.0\npip install nvidia-cudnn-cu11==8.6.0.163\n\nmkdir -p ${CONDA_PREFIX}/etc/conda/activate.d\nD=${CONDA_PREFIX}/etc/conda/activate.d/env.sh\necho 'export PYTHONNOUSERSITE=1' &gt;&gt; $D\necho 'export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${CONDA_PREFIX}/lib' &gt;&gt; $D\necho 'export CUDNN_PATH=$(dirname $(python -c \"import nvidia.cudnn;print(nvidia.cudnn.__file__)\"))' &gt;&gt; $D\necho 'export LD_LIBRARY_PATH=$CONDA_PREFIX/lib/:$CUDNN_PATH/lib:$LD_LIBRARY_PATH' &gt;&gt; $D\n</code></pre>"},{"location":"Running/","title":"Running","text":"<p>Assuming you have installed the right igm environment, the glacier evolution model IGM can be run via the command <code>igm_run</code>: define     igm_run --RGI-ID RGI60-11.01450 --time_start 2023 --time_end 2100</p> <p>where parameters are given in command line as above or in a file params.json (recommended) like </p> <pre><code>{\n  \"modules_preproc\": [\"oggm_shop\"],\n  \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\"],\n  \"modules_postproc\": [\"write_ncdf\",\"plot2d\",\"print_info\",\"print_comp\"],\n  \"oggm_RGI_ID\": \"RGI60-11.01238\",\n  \"time_start\": 2023.0,\n  \"time_end\": 2100.0\n}\n</code></pre> <p>and igm_run.py is a short python script located in the root directory that perform the following steps (check the code for more details):</p> <ul> <li>collect parameters into <code>params</code> object, including the ordered list of modules <code>modules</code>,</li> <li>define a <code>state</code> object that contains all the data (e.g. ice thickness),</li> <li>initialize all model components in turn,</li> <li>update all model components in turn within a time loop from start to end times,</li> <li>finalize all model components in turn.</li> </ul> <p>Therefore running IGM requires to define parameters <code>params</code>, which includes first-of-all the list of wished IGM modules.</p> <p>IGM can also take the parameter file as input as follows: <code>igm_run --param_file params1.json</code></p>"},{"location":"Running/#parameters-params-full-list","title":"Parameters (<code>params</code>, full list)","text":"<p>IGM has a few core parameters:</p> short long default help <code>--param_file</code> <code>params.json</code> Parameter file <code>--modules_preproc</code> <code>[\"prepare_data\"]</code> List of pre-processing modules <code>--modules_process</code> <code>[\"iceflow\",\"time\",\"thk\"]</code> List of processing modules <code>--modules_postproc</code> <code>[\"write_ncdf\",\"print_info\"]</code> List of post-processing modules <code>--logging</code> <code>False</code> Activate the logging <p>and many other module-specific parameters, see the full list of parameters or the  module documentation for the meaning and default values of the parameters of each module. Parameters passed in command line override those passed in the jon parameter file, which override the default IGM parameters.</p>"},{"location":"Running/#modules-modules","title":"Modules (modules)","text":"<p>IGM is organized module-wise. Each user must pick a sequence of existing pre-processing, processing, post-processing and/or user-made modules she/he wishes to have for her/his application (check at the module documentation. Each module implements all least 4 functions for module-specific parameter definition, initialization, update and finalization, which are called by <code>igm_run</code>. This section helps to chose the appropriate module. First one needs pre-processing modules:</p> <ul> <li>For modelling individual present-day glacier, the best is to use the OGGM-based <code>prepare_data</code> module, which take care of downloading all the gridded data appropriatly. In that case, the <code>modules_preproc</code> in the json parameter file look like:  <pre><code>   \"modules_preproc\": [\"oggm_shop\"], \n</code></pre></li> <li> <p>Alternatively to module <code>oggm_shop</code>, one may load the data directly NetCDF file (with module <code>load_ncdf</code>), tif file (with module <code>load_tif</code>) or from analytical formula for synthetic glacier tests (<code>synthetic</code>).</p> </li> <li> <p>Optionally the additional module <code>optimize</code> permits to do data assimilation seeking for ice thickness distribution, ice flow parameters that yield the best fit with data (e.g. surface ice speeds). In that case, the `modules_preproc in the json parameter file look like:  <pre><code>\"modules_preproc\": [\"prepare_data\",\"optimize\"],\n</code></pre> Second one needs to define processing modules:</p> </li> <li> <p>The minimum to have as processing is the combination of ice flow (module <code>iceflow</code>), ice thickness (module <code>thk</code>), and time step (module <code>time</code>):</p> </li> </ul> <pre><code>  \"modules_process\": [\"iceflow\"\",\"time\",\"thk\"],\n</code></pre> <ul> <li>However, it sounds reasonable to add at least a surface mass balance module (e.g. <code>smb_simple</code>), and other components we like to have (e.g. computation of vertical velocity, particle trajectory, climate, enthalpy, ...) making sure to respect a logical order, i.e., </li> </ul> <pre><code>  \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\",\"vert_flow\",\"particles\"],\n</code></pre> <p>Then, one needs post-processing modules to output the results of the model, e.g. this line will permit to write model output in NetCDF files, make 2D plots, print basic informatinN (e.g. ice volume), and produce a nice 3D animation of the run at the end:</p> <pre><code>  \"modules_postproc\": [ \"write_ncdf\", \"plot2d\", \"print_info\",  \"anim_mayavi\" ]\n</code></pre> <p>Lastly, one often needs to customize the code for specific applications. This is easy to do so with IGM, e.g. for imposing own climate forcing, defining own surface mass balance, ... For that purpose, implement your module in a separate file my_mod.py, and add it to the workflow</p> <p><pre><code>  \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\",\"my_mod\"],\n</code></pre> then, the module will be automatically loaded by <code>igm_run</code> when being executed.</p>"},{"location":"about/credits_and_references/","title":"References","text":"<p>There is currently an in-progress IGM technical paper that will give you an overview of the physical components, modules, and capabilities of IGM.</p> <p>If you use IGM in publications, make sure to cite one of the following papers and the code version you used.</p> <p><pre><code>@article{IGM,\n    author       = \"Jouvet, Guillaume and Cordonnier, Guillaume and Kim, Byungsoo and L\u00fcthi, Martin and Vieli, Andreas and Aschwanden, Andy\",  \n    title        = \"Deep learning speeds up ice flow modelling by several orders of magnitude\",\n    DOI          = \"10.1017/jog.2021.120\",\n    journal      = \"Journal of Glaciology\",\n    year         =  2021,\n    pages        = \"1\u201314\",\n    publisher    = \"Cambridge University Press\"\n}\n</code></pre> <pre><code>@article{IGM-inv,\n    author       = \"Jouvet, Guillaume\",\n    title        = \"Inversion of a Stokes ice flow model emulated by deep learning\",\n    DOI          = \"10.1017/jog.2022.41\",\n    journal      = \"Journal of Glaciology\",\n    year         = \"2022\",\n    pages        = \"1--14\",\n    publisher    = \"Cambridge University Press\"\n}\n</code></pre> <pre><code>@article{IGM-PINN,\n    title={Ice-flow model emulator based on physics-informed deep learning},\n    author={Jouvet, Guillaume and Cordonnier, Guillaume},\n    journal={Journal of Glaciology},\n    pages={1--15},\n    year={2023},\n    publisher={Cambridge University Press},\n    doi={10.1017/jog.2023.73}\n}\n</code></pre></p>"},{"location":"about/credits_and_references/#acknowledgements","title":"Acknowledgements","text":"<p>I greatly thank Guillaume Cordonnier for his valuable help with the TensorFlow implementation. The Parallel Ice Sheet Model has greatly inspired the naming of variables, as well as the format of input and output NetCDF files.</p>"},{"location":"about/custom_modules/","title":"Custom","text":"<p>It is fairly simple to write your own module in a separate python file and include it in the workflow, e.g. to force a climate and/or surface mass balance model specific to an application. For that, one needs to undestand how IGM is coded.</p>"},{"location":"about/custom_modules/#coding-structure","title":"Coding structure","text":"<p>A closer look at script igm_run.py reveals the following main steps:</p> <ul> <li>Load key libraries (tensorflow and igm):</li> <li>Collect defaults, overide from json file, and parse all core and specific module parameters into params, load custom modules, and get the list of all modules in order:</li> <li>Define a state class/dictionnary that contains all the data (e.g. ice thickness)</li> <li>Initialize, update and finalize all model components in given order after placing on '/CPU:0' or '/GPU:0' device.</li> </ul> <p>Each module have at least 4 functions defined (some may do nothing, but still need to be defined): </p> <ul> <li>a parameter function 'params(parser)' that defines the parameter associated with the module, </li> <li>an initialization function 'initialize(params,state)' that initializes all that needs to be prior to the main time loop, </li> <li>an update function 'update(parser)' that updates the state within the main time loop, </li> <li>a finalize function 'finalize(parser)' that finalizes the module after the time loop.</li> </ul> <p>In <code>igm_run</code>, all variables describing the glacier state at a time t are stored in the <code>state</code> object. All these variable are TensorFlow 2.0 Tensors. Using Tensorflow is key to making computationally efficient operations, especially on GPU. Any variables can be accessed/modified via state.nameofthevariable, e.g.,</p> <p><pre><code>state.thk   # is the ice thickness variable\nstate.usurf # is the top surface elevation\n</code></pre> Variables names are summarized here.</p>"},{"location":"about/custom_modules/#creating-own-module","title":"Creating own module","text":"<p>Similarly to existing IGM ones, a user-defined module my_module can be implemented in a file my_module.py, which will be will automatically loaded when <code>igm_run</code> is executed providing <code>my_module</code> is listed in any module list parameters. The implementation must have the 4 functions that permits to defined parameters, initializing, updating, and finalizing. For instance, to implementation of the mass balance function 'sinus' with an oscillating ELA, you may create a module <code>mysmb</code> in a file mysmb.py, which update the object state.smb from other fields and parameters:</p> <pre><code>def params(parser):  \n    parser.add_argument(\"--meanela\", type=float, default=3000 )\n\ndef initialize(params,state):\n    pass\n\ndef update(params,state):\n    # perturabe the ELA with sinusional signal \n    ELA = ( params.meanela + 750*math.sin((state.t/100)*math.pi) )\n    # compute smb linear with elevation with 2 acc &amp; abl gradients\n    state.smb  = state.usurf - ELA\n    state.smb *= tf.where(state.smb&lt;0, 0.005, 0.009)\n    # cap smb by 2 m/y \n    state.smb  = tf.clip_by_value(state.smb, -100, 2)\n    # make sure the smb is not positive outside of the mask to prevent overflow\n    state.smb  = tf.where((state.smb&lt;0)|(state.icemask&gt;0.5),state.smb,-10)\n\ndef finalize(params,state):\n    pass\n</code></pre> <p>then, it remains to call these new function and add 'mysmb' to the list of modules as parameter.</p> <p>Note that the four functions (params, init, update, finalize) must be defined even if some are not doing anything (just use <code>pass</code>). You may find coding inspiration / examples looking at the code of IGM modules above.</p>"},{"location":"about/custom_modules/#overriding-modules","title":"Overriding modules","text":"<p>Sometime, it may happen that you would like to bring a minor modification to an existing module. If so, no need to copy/paste the entire module and bring your modification, you may simply define a module with the same name existingmodule.py that contains only the function you would like to modify. All other function will be taken from the orginal module. For instance, this IGM example implements a special seeding strategy for the particle module in user-defined particles.py. Only two functions of the module are changed.</p>"},{"location":"about/custom_modules/#sharing-your-module","title":"Sharing your module","text":"<p>If you have developed a module that you believe may be useful to the community and be shared within igm package, read this section carefully. First, give a meaningful name to your module, and try to match the structure of other existing modules for consistency. Please name modulename.py and modulename.md the python and the documentation files, respectively. The parameter list coming at the end of modulename.md in the doc folder will be generated automatically, so you don't need to do it yourself. Please make sure to name all parameters of your module with a 4 letter long keyword that shorten the name of your module. This permits to prevent against conflicts between parameter names of different modules. Once all of this is achieve, you may contact me, or do a pull request.</p>"},{"location":"about/gpus/","title":"Graphical Processing Units (GPUs)","text":"<p>IGM works fine on CPU for small computational domains (typically individual glaciers). In contrast, GPUs will be very advantageous to treat very large computational grids (typically large networks of glaciers) as IGM naturally takes further benefit from parallelism. </p> Resolution Minimum computational ressource 0.25 K: 256 x 192 pixel CPU 1 K   : 1024 x 768 pixel laptop GPU    e.g., RTX A4000 4 K   : 3840 x 2160 pixel excellent GPU  e.g., RTX 4090 <p>To illustrate this, I modeled the ice dynamics and glacier evolution over New Zealand by forcing the mass balance with an ELA oscillating between 1000 and 2000 meters a.s.l. The 1000-year-long simulation took about 1.5 hours on the Nvidia RTX 3090 GPU with a 640x700 km computational domain at 200 meters of resolution (i.e. 3200x3500 grid). The animation can be visualized on this link.</p>"},{"location":"about/tensorflow/","title":"Tensorflow","text":"<p>IGM fully relies on TensorFlow 2.0 library for computational efficiency on GPU. All variables (e.g. ice thickness) are TensorFlow tensor objects, which can only be modified using TensorFlow operations. All these operations are vectorial, i.e. they apply simultaneously to all entries of 2D gridded fields, which is key for parallel and efficient execution. This means that one must avoid any sequential operations (typically loop of indices of 2D arrays), and favour TensorFlow (optimized) operations between large arrays (e.g. neural networks). </p> <p>At first sight, a lot of TensorFlow functions look similar to Numpy ones, one can simply do operations by changing numpy to tensorflow, e.g. 'tf.zeros()' instead of 'np.zeros()' with 'import tensorflow as tf' instead of 'import numpy as np'. E.g. Tensorflow operations look like: <pre><code>state.topg  = tf.zeros_like(state.usurf)                                  # define Variable Tensor\nstate.smb   = tf.where(state.usurf &gt; 4000, 0, state.smb)                   # Imposes zero mass balance above 4000 m asl.\nstate.usurf = state.topg + state.thk                                       # Update surface topography with new ice thickness\nstate.smb   = tf.clip_by_value( (state.usurf - ela)*grad , -100, 2.0 )     # Define linear smb wrt z, with capping value\nu = tf.concat( [u[:, 0:1], 0.5 * (u[:, :-1] + u[:, 1:]), u[:, -1:]], 1 )   # work on straggered grid\n</code></pre> In fact, there are two kinds of tensor that are used in IGM. First, \"EagerTensor\" (as shown above) can make many operations, however, we can NOT change specific tensor entries (slicing): <pre><code>tensor = tf.ones((500,300))  \ntensor = (2*tensor + 200)**2\ntensor[1,2] = 5 # WILL NOT WORK\n</code></pre> As a workaround, one uses \"tf.Variable\" that permits to slice, however, the assignment is slightly different, it can not be done with \"=\", but with the \"assign\" function: <pre><code>tensor = tf.Variable(tf.ones((500,300)))\ntensor.assign( (2*tensor + 200)**2 )\ntensor[1,2].assign( 5 ) # WORKS !\n</code></pre> IGM combines both types of tensors, so make sure to identify what is your type, other TF will produce an error.</p> <p>For the best computational efficiency, it is crucial to keep all variables and operations within the TensorFlow framework without using Numpy (to avoid unnecessary transfers between GPU and CPU memory). There is the possibility to generate TensorFlow function using Numpy code, check at this page.</p> <p>The best way to learn how to code with tensorflow within the context of IGM is to explore module codes, or to look at examples.</p>"},{"location":"about/variables/","title":"Variables","text":"<p>Whenever this is possible, IGM adopts name convention of PISM. Here is a minimal list of key variables:</p> Variable names Shape Description Unit t () Time variable (scalar) y dt () Time step (scalar) y x,y (nx) Coordinates vectors m thk (ny) Ice thickness m topg (ny,nx) Basal topography (or bedrock) m usurf (ny,nx) Surface topography m smb (ny,nx) Surface Mass Balance m/y ice-eq ubar (ny,nx) x- depth-average velocity of ice m/y vbar (ny,nx) y- depth-average velocity of ice m/y U (nz,ny,nx) x-horiz. 3D velocity field of ice m/y V (nz,ny,nx) y-horiz. 3D velocity field of ice m/y W (nz,ny,nx) z-vert.  3D velocity field of ice m/y arrhenius (ny,nx) Arrhenius Factor MPa^(-3) y^(-1) slidingco (ny,nx) Sliding Coefficient \\(\\(MPa m^{-1/3} y^(-1/3)\\)\\) divflux (ny,nx) Divergence of the flux m/y icemask (ny,nx) Mask to restrict the smb comp. - dtopgdt (ny,nx) Erosion rate m/y xpos,ypos (nb particles) x,y position of particles m rhpos (nb particles) rel. pos of particles in ice column m air_temp (nt,ny,nx) seasonal air temperature 2 m above ground \u00b0C precipitation (nt,ny,nx) seasonal precipitation (water eq) kg m^(-2) y^(-1)"},{"location":"examples/Examples/","title":"Examples","text":"<p>The best and quickest way to get to know IGM is to run given examples. Having IGM installed on your machine, you can simply run <code>igm_run</code> in a folder that contains the following parameter file <code>params.json</code>:</p> <pre><code>{\n  \"modules_preproc\": [\"oggm_shop\"],\n  \"modules_process\": [\"clim_oggm\",\n                      \"smb_oggm\",\n                      \"iceflow\",\n                      \"time\",\n                      \"thk\"\n                      ],\n  \"modules_postproc\": [\"write_ncdf\",\n                       \"plot2d\",\n                       \"print_info\",\n                       \"print_comp\"],\n  \"clim_oggm_clim_trend_array\": [\n                        [\"time\", \"delta_temp\", \"prec_scal\"],\n                        [ 1900,           0.0,         1.0],\n                        [ 2020,           0.0,         1.0],\n                        [ 2100,           4.0,         1.0]\n                                 ],\n  \"oggm_RGI_ID\": \"RGI60-11.01450\",\n  \"time_start\": 1800.0,\n  \"time_end\": 2100.0,\n  \"plt2d_live\": true,\n  \"iflo_init_slidingco\": 0.25\n}\n</code></pre> <p>You may run other ready-to-use examples in the folder <code>test/examples/</code> in the develop version, which contains input data and parameter files. To run the example, just go in each folder and run <code>igm_run</code> there. You have the following examples available:</p> <ul> <li> <p>quick-demo provides a set-up to model any glacier given an RGI ID, with a OGGM-based climate forcing and SMB. </p> </li> <li> <p>quick-demo-mysmb is like quick-demo but wirh a own user-defined SMB module / parametrization.</p> </li> <li> <p>aletsch-basic provides a simple set-up for an advance-retreat simulation of the largest glacier of the European Alps -- Aletsch Glacier, Switzerland -- using a simple parametrization of the mass balance based on time-varying Equilibrium Line Altitudes (ELA).</p> </li> <li> <p>aletsch-1880-2100 gives the set-up to reproduce the simulations of the Great Aletsch Glacier (Switzerland) in the past and in the future based on the CH2018 climate scenarios and an accumulation/melt model.</p> </li> <li> <p>aletsch-invert and rhone-invert gives an example of data assimilation with IGM (Warning: inverse modelling requires tuning parameters for each glacier). rhone-invert is the most advanced/recent setting.</p> </li> <li> <p>paleo-alps consists of a simple set-up to run a paleo glacier model in the European Alps in paleo times with different catchments (lyon, ticino, rhine, linth glaciers) with IGM around the last glacial maximum (LGM, about 24 BP in the Alps).</p> </li> <li> <p>synthetic permits to make simple numerical experiments with simple synthetic bedrock topographies.</p> </li> </ul>"},{"location":"examples/aletsch_basic/","title":"Setup","text":"config.yaml<pre><code>modules_preproc:\n  - load_ncdf\nmodules_process:\n  - smb_simple\n  - iceflow\n  - time\n  - thk\n  - vert_flow\n  - particles\nmodules_postproc:\n  - write_ncdf\n  - plot2d\n  - print_info\n  - print_comp\nsmb_simple_array:\n  - [\"time\", \"gradabl\", \"gradacc\", \"ela\", \"accmax\"]\n  - [1900, 0.009, 0.005, 2800, 2.0]\n  - [2000, 0.009, 0.005, 2900, 2.0]\n  - [2100, 0.009, 0.005, 3300, 2.0]\ntime_start: 1900.0\ntime_end: 2000.0\nurl_data: https://www.dropbox.com/scl/fo/kd7dix5j1tm75nj941pvi/h?rlkey=q7jtmf9yn3a970cqygdwne25j&amp;dl=0\nlncd_input_file: data/input.nc\nplt2d_live: true\ntime_save: 10.0\n</code></pre>"},{"location":"examples/quick_demo/","title":"Quick Demo","text":""},{"location":"examples/quick_demo/#macros-plugin-environment","title":"Macros Plugin Environment","text":""},{"location":"examples/quick_demo/#general-list","title":"General List","text":"<p>All available variables and filters within the macros plugin:</p> Variable Type Content extra dict version [dict] config MkDocsConfig {'config_file_path': '/home/bfinley/PhD/igm-doc/mike-mkdocswt7fsw3y.yml', 'site_name': 'Instructed Glacier Model (IGM)', 'nav': [{'Home': 'index.md'}, {'Installation': [{'Quick Start': 'installation/quick_start.md'}, {'Other': [{'Nvidia Drivers': 'installation/other/nvidia_drivers.md'}, {'Virtual Environments': 'installation/other/virtual_environment.md'}, {'WSL Windows': 'installation/other/wsl_windows.md'}]}]}, {'Getting Started': [{'Using Hydra': [{'Introduction': 'hydra/introduction.md'}, {'Configuration': 'hydra/configuration.md'}, {'Distributed Computing': 'hydra/distributed_computing.md'}]}, {'Examples': [{'Quick Demo': 'examples/quick_demo.md'}, {'Aletsch Basic': 'examples/aletsch_basic.md'}]}]}, {'Modules': [{'What are modules?': 'modules/introduction.md'}, {'Input': [{'load_ncdf': 'modules/inputs/load_ncdf.md'}, {'load_tif': 'modules/inputs/load_tif.md'}, {'oggm_shop': 'modules/inputs/oggm_shop.md'}]}, {'Processes': [{'avalanche': 'modules/processes/avalanche.md'}, {'clim_oggm': 'modules/processes/clim_oggm.md'}, {'enthalpy': 'modules/processes/enthalpy.md'}, {'gflex': 'modules/processes/gflex.md'}, {'glerosion': 'modules/processes/glerosion.md'}, {'iceflow': 'modules/processes/iceflow.md'}, {'particles': 'modules/processes/particles.md'}, {'print_info': 'modules/processes/print_info.md'}, {'read_output': 'modules/processes/read_output.md'}, {'rockflow': 'modules/processes/rockflow.md'}, {'smb_accpdd': 'modules/processes/smb_accpdd.md'}, {'smb_oggm': 'modules/processes/smb_oggm.md'}, {'smb_simple': 'modules/processes/smb_simple.md'}, {'texture': 'modules/processes/texture.md'}, {'thk': 'modules/processes/thk.md'}, {'time': 'modules/processes/time.md'}, {'vert_flow': 'modules/processes/vert_flow.md'}]}, {'Output': [{'write_ncdf': 'modules/outputs/write_ncdf.md'}, {'write_particles': 'modules/outputs/write_particles.md'}, {'write_tif': 'modules/outputs/write_tif.md'}, {'write_ts': 'modules/outputs/write_ts.md'}, {'plot2d': 'modules/outputs/plot2d.md'}]}, {'Custom': 'about/custom_modules.md'}]}, {'About': [{'Graphical Processing Units (GPUs)': 'about/gpus.md'}, {'Tensorflow': 'about/tensorflow.md'}, {'Crediting IGM': 'about/credits_and_references.md'}, {'Variables': 'about/variables.md'}]}], 'pages': None, 'exclude_docs': None, 'draft_docs': None, 'not_in_nav': None, 'site_url': 'https://jouvetg.github.io/igm-doc.github.io/2.2.3', 'site_description': 'Run your own glacier simulations in a fast, accurate, and user-friendly way.', 'site_author': None, 'theme': Theme(name='material', dirs=['/home/bfinley/PhD/igm-doc/docs/material/overrides', '/home/bfinley/anaconda3/lib/python3.11/site-packages/material/templates', '/home/bfinley/anaconda3/lib/python3.11/site-packages/mkdocs/templates'], static_templates={'404.html', 'sitemap.xml'}, name='material', locale=Locale('en'), language='en', direction=None, features=['content.code.copy', 'content.code.annotate', 'content.code.select', 'navigation.path', 'navigation.instant.progress', 'navigation.tabs', 'navigation.footer', 'toc.integrate', 'toc.follow', 'search.highlight', 'search.suggest'], font={'text': 'Inter', 'code': 'Fira Code'}, icon=None, favicon='assets/favicon.ico', logo='assets/logo.svg', palette=[{'scheme': 'glacier_light', 'toggle': {'icon': 'material/weather-night', 'name': 'Switch to dark mode'}}, {'scheme': 'glacier_dark', 'toggle': {'icon': 'material/weather-sunny', 'name': 'Switch to light mode'}}]), 'docs_dir': '/home/bfinley/PhD/igm-doc/docs', 'site_dir': '/home/bfinley/PhD/igm-doc/site', 'copyright': None, 'google_analytics': None, 'dev_addr': _IpAddressValue(host='127.0.0.1', port=8000), 'use_directory_urls': True, 'repo_url': 'https://github.com/jouvetg/igm', 'repo_name': 'jouvetg/igm', 'edit_uri_template': None, 'edit_uri': 'edit/master/docs/', 'extra_css': ['stylesheets/extra.css'], 'extra_javascript': ['javascripts/mathjax.js', 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML', 'https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js'], 'extra_templates': [], 'markdown_extensions': ['toc', 'tables', 'fenced_code', 'pymdownx.highlight', 'pymdownx.inlinehilite', 'pymdownx.snippets', 'pymdownx.superfences', 'admonition', 'pymdownx.details', 'pymdownx.arithmatex'], 'mdx_configs': {'pymdownx.highlight': {'anchor_linenums': True, 'line_spans': '__span', 'pygments_lang_class': True}, 'pymdownx.arithmatex': {'generic': True}}, 'strict': False, 'remote_branch': 'gh-pages', 'remote_name': 'origin', 'extra': {'version': {'provider': 'mike'}}, 'plugins': {'mike': , 'material/search': , 'include-markdown': , 'table-reader': , 'macros': }, 'hooks': {}, 'watch': [], 'validation': {'nav': {'omitted_files': 20, 'not_found': 30, 'absolute_links': 20}, 'links': {'not_found': 30, 'absolute_links': 20, 'unrecognized_links': 20, 'anchors': 20}}} environment dict system = 'Linux', system_version = '6.8.0-52-generic', python_version = '3.11.7', mkdocs_version = '1.6.0', macros_plugin_version = '1.3.7', jinja2_version = '3.1.3' plugin LegacyConfig {'module_name': 'main', 'modules': [], 'render_by_default': True, 'force_render_paths': '', 'include_dir': './igm/igm/', 'include_yaml': [], 'j2_block_start_string': '', 'j2_block_end_string': '', 'j2_variable_start_string': '', 'j2_variable_end_string': '', 'j2_comment_start_string': '', 'j2_comment_end_string': '', 'on_undefined': 'keep', 'on_error_fail': False, 'verbose': False} git dict status = True, date [datetime], short_commit = 'dce7505', commit = 'dce7505609343ee95f4707b1a9cc8442f8f68b02', tag = '', short_tag = '', author = 'brfi3983', author_email = 'brandon.finley@unil.ch', committer = 'brfi3983', committer_email = 'brandon.finley@unil.ch', date_ISO = 'Mon Mar 24 14:11:21 2025 +0100', message = 'got website to work with automated tables with new conf help structure\\n\\n- renamed input to inputs, modules to processes, and output to outputs\\n- deleted old_modules from markdown\\n- adapted documenation to new IGM conf help structure (simplified it a bit)\\n- got iceflow to have subtables (will work on collapsable tables next...)\\n- got latex rendering to work as well for tables', raw = 'commit dce7505609343ee95f4707b1a9cc8442f8f68b02\\nAuthor: brfi3983 \\nDate:   Mon Mar 24 14:11:21 2025 +0100\\n\\n    got website to work with automated tables with new conf help structure\\n    \\n    - renamed input to inputs, modules to processes, and output to outputs\\n    - deleted old_modules from markdown\\n    - adapted documenation to new IGM conf help structure (simplified it a bit)\\n    - got iceflow to have subtables (will work on collapsable tables next...)\\n    - got latex rendering to work as well for tables', root_dir = '/home/bfinley/PhD/igm-doc' version SuperDict provider = 'mike' macros SuperDict context [function], macros_info [function], now [function], fix_url [function], load_yaml [function] filters dict pretty [function], relative_url [function] filters_builtin dict abs [builtin_function_or_method], attr [function], batch [function], capitalize [function], center [function], count [builtin_function_or_method], d [function], default [function], dictsort [function], e [builtin_function_or_method], escape [builtin_function_or_method], filesizeformat [function], first [function], float [function], forceescape [function], format [function], groupby [function], indent [function], int [function], join [function], last [function], length [builtin_function_or_method], list [function], lower [function], items [function], map [function], min [function], max [function], pprint [function], random [function], reject [function], rejectattr [function], replace [function], reverse [function], round [function], safe [function], select [function], selectattr [function], slice [function], sort [function], string [builtin_function_or_method], striptags [function], sum [function], title [function], trim [function], truncate [function], unique [function], upper [function], urlencode [function], urlize [function], wordcount [function], wordwrap [function], xmlattr [function], tojson [function] navigation Navigation files Files page Page Page(title='Quick Demo', url='/igm-doc.github.io/2.2.3/examples/quick_demo/')"},{"location":"examples/quick_demo/#config-information","title":"Config Information","text":"<p>Standard MkDocs configuration information. Do not try to modify.</p> <p>e.g. <code>{{ config.docs_dir }}</code></p> <p>See also the MkDocs documentation on the config object.</p> Variable Type Content config_file_path str '/home/bfinley/PhD/igm-doc/mike-mkdocswt7fsw3y.yml' site_name str 'Instructed Glacier Model (IGM)' nav list [{'Home': 'index.md'}, {'Installation': [{'Quick Start': 'installation/quick_start.md'}, {'Other': [{'Nvidia Drivers': 'installation/other/nvidia_drivers.md'}, {'Virtual Environments': 'installation/other/virtual_environment.md'}, {'WSL Windows': 'installation/other/wsl_windows.md'}]}]}, {'Getting Started': [{'Using Hydra': [{'Introduction': 'hydra/introduction.md'}, {'Configuration': 'hydra/configuration.md'}, {'Distributed Computing': 'hydra/distributed_computing.md'}]}, {'Examples': [{'Quick Demo': 'examples/quick_demo.md'}, {'Aletsch Basic': 'examples/aletsch_basic.md'}]}]}, {'Modules': [{'What are modules?': 'modules/introduction.md'}, {'Input': [{'load_ncdf': 'modules/inputs/load_ncdf.md'}, {'load_tif': 'modules/inputs/load_tif.md'}, {'oggm_shop': 'modules/inputs/oggm_shop.md'}]}, {'Processes': [{'avalanche': 'modules/processes/avalanche.md'}, {'clim_oggm': 'modules/processes/clim_oggm.md'}, {'enthalpy': 'modules/processes/enthalpy.md'}, {'gflex': 'modules/processes/gflex.md'}, {'glerosion': 'modules/processes/glerosion.md'}, {'iceflow': 'modules/processes/iceflow.md'}, {'particles': 'modules/processes/particles.md'}, {'print_info': 'modules/processes/print_info.md'}, {'read_output': 'modules/processes/read_output.md'}, {'rockflow': 'modules/processes/rockflow.md'}, {'smb_accpdd': 'modules/processes/smb_accpdd.md'}, {'smb_oggm': 'modules/processes/smb_oggm.md'}, {'smb_simple': 'modules/processes/smb_simple.md'}, {'texture': 'modules/processes/texture.md'}, {'thk': 'modules/processes/thk.md'}, {'time': 'modules/processes/time.md'}, {'vert_flow': 'modules/processes/vert_flow.md'}]}, {'Output': [{'write_ncdf': 'modules/outputs/write_ncdf.md'}, {'write_particles': 'modules/outputs/write_particles.md'}, {'write_tif': 'modules/outputs/write_tif.md'}, {'write_ts': 'modules/outputs/write_ts.md'}, {'plot2d': 'modules/outputs/plot2d.md'}]}, {'Custom': 'about/custom_modules.md'}]}, {'About': [{'Graphical Processing Units (GPUs)': 'about/gpus.md'}, {'Tensorflow': 'about/tensorflow.md'}, {'Crediting IGM': 'about/credits_and_references.md'}, {'Variables': 'about/variables.md'}]}] pages NoneType None exclude_docs NoneType None draft_docs NoneType None not_in_nav NoneType None site_url str 'https://jouvetg.github.io/igm-doc.github.io/2.2.3' site_description str 'Run your own glacier simulations in a fast, accurate, and user-friendly way.' site_author NoneType None theme Theme Theme(name='material', dirs=['/home/bfinley/PhD/igm-doc/docs/material/overrides', '/home/bfinley/anaconda3/lib/python3.11/site-packages/material/templates', '/home/bfinley/anaconda3/lib/python3.11/site-packages/mkdocs/templates'], static_templates={'404.html', 'sitemap.xml'}, name='material', locale=Locale('en'), language='en', direction=None, features=['content.code.copy', 'content.code.annotate', 'content.code.select', 'navigation.path', 'navigation.instant.progress', 'navigation.tabs', 'navigation.footer', 'toc.integrate', 'toc.follow', 'search.highlight', 'search.suggest'], font={'text': 'Inter', 'code': 'Fira Code'}, icon=None, favicon='assets/favicon.ico', logo='assets/logo.svg', palette=[{'scheme': 'glacier_light', 'toggle': {'icon': 'material/weather-night', 'name': 'Switch to dark mode'}}, {'scheme': 'glacier_dark', 'toggle': {'icon': 'material/weather-sunny', 'name': 'Switch to light mode'}}]) docs_dir str '/home/bfinley/PhD/igm-doc/docs' site_dir str '/home/bfinley/PhD/igm-doc/site' copyright NoneType None google_analytics NoneType None dev_addr _IpAddressValue _IpAddressValue(host='127.0.0.1', port=8000) use_directory_urls bool True repo_url str 'https://github.com/jouvetg/igm' repo_name str 'jouvetg/igm' edit_uri_template NoneType None edit_uri str 'edit/master/docs/' extra_css list ['stylesheets/extra.css'] extra_javascript list ['javascripts/mathjax.js', 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML', 'https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js'] extra_templates list [] markdown_extensions list ['toc', 'tables', 'fenced_code', 'pymdownx.highlight', 'pymdownx.inlinehilite', 'pymdownx.snippets', 'pymdownx.superfences', 'admonition', 'pymdownx.details', 'pymdownx.arithmatex'] mdx_configs dict pymdownx.highlight [dict], pymdownx.arithmatex [dict] strict bool False remote_branch str 'gh-pages' remote_name str 'origin' extra LegacyConfig {'version': {'provider': 'mike'}} plugins PluginCollection mike [MikePlugin], material/search [SearchPlugin], include-markdown [IncludeMarkdownPlugin], table-reader [TableReaderPlugin], macros [MacrosPlugin] hooks dict watch list [] validation Validation {'nav': {'omitted_files': 20, 'not_found': 30, 'absolute_links': 20}, 'links': {'not_found': 30, 'absolute_links': 20, 'unrecognized_links': 20, 'anchors': 20}}"},{"location":"examples/quick_demo/#macros","title":"Macros","text":"<p>These macros have been defined programmatically for this environment (module or pluglets). </p>"},{"location":"examples/quick_demo/#typeerror-isinstance-arg-2-must-be-a-type-a-tuple-of-types-or-a-union","title":"TypeError: isinstance() arg 2 must be a type, a tuple of types, or a union","text":"<p>Traceback (most recent call last):   File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/mkdocs_macros/context.py\", line 355, in pretty     rows = [(\"%s\" % var, \"%s\" % var_type,            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/mkdocs_macros/context.py\", line 355, in      rows = [(\"%s\" % var, \"%s\" % var_type,              ~~~~~~~~~~~~^~~~~   File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/super_collections/init.py\", line 168, in str     return self.to_hjson()            ^^^^^^^^^^^^^^^   File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/super_collections/init.py\", line 162, in to_hjson     python_dict = json.loads(self.to_json())                              ^^^^^^^^^^^^^^   File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/super_collections/init.py\", line 152, in to_json     return json.dumps(self, cls=CustomEncoder)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/home/bfinley/anaconda3/lib/python3.11/json/init.py\", line 238, in dumps     **kw).encode(obj)           ^^^^^^^^^^^   File \"/home/bfinley/anaconda3/lib/python3.11/json/encoder.py\", line 200, in encode     chunks = self.iterencode(o, _one_shot=True)              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/home/bfinley/anaconda3/lib/python3.11/json/encoder.py\", line 258, in iterencode     return _iterencode(o, 0)            ^^^^^^^^^^^^^^^^^   File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/super_collections/init.py\", line 33, in default     if isinstance(obj, datetime):        ^^^^^^^^^^^^^^^^^^^^^^^^^ TypeError: isinstance() arg 2 must be a type, a tuple of types, or a union"},{"location":"examples/quick_demo/#git-information","title":"Git Information","text":"<p>Information available on the last commit and the git repository containing the documentation project:</p> <p>e.g. <code>{{ git.message }}</code></p> Variable Type Content status bool True date datetime datetime.datetime(2025, 3, 24, 14, 11, 21, tzinfo=tzoffset(None, 3600)) short_commit str 'dce7505' commit str 'dce7505609343ee95f4707b1a9cc8442f8f68b02' tag str '' short_tag str '' author str 'brfi3983' author_email str 'brandon.finley@unil.ch' committer str 'brfi3983' committer_email str 'brandon.finley@unil.ch' date_ISO str 'Mon Mar 24 14:11:21 2025 +0100' message str 'got website to work with automated tables with new conf help structure\\n\\n- renamed input to inputs, modules to processes, and output to outputs\\n- deleted old_modules from markdown\\n- adapted documenation to new IGM conf help structure (simplified it a bit)\\n- got iceflow to have subtables (will work on collapsable tables next...)\\n- got latex rendering to work as well for tables' raw str 'commit dce7505609343ee95f4707b1a9cc8442f8f68b02\\nAuthor: brfi3983 \\nDate:   Mon Mar 24 14:11:21 2025 +0100\\n\\n    got website to work with automated tables with new conf help structure\\n    \\n    - renamed input to inputs, modules to processes, and output to outputs\\n    - deleted old_modules from markdown\\n    - adapted documenation to new IGM conf help structure (simplified it a bit)\\n    - got iceflow to have subtables (will work on collapsable tables next...)\\n    - got latex rendering to work as well for tables' root_dir str '/home/bfinley/PhD/igm-doc'"},{"location":"examples/quick_demo/#page-attributes","title":"Page Attributes","text":"<p>Provided by MkDocs. These attributes change for every page (the attributes shown are for this page).</p> <p>e.g. <code>{{ page.title }}</code></p> <p>See also the MkDocs documentation on the page object.</p> Variable Type Content file File src_uri = 'examples/quick_demo.md', src_dir = '/home/bfinley/PhD/igm-doc/docs', dest_dir = '/home/bfinley/PhD/igm-doc/site', use_directory_urls = True, inclusion [InclusionLevel], name = 'quick_demo', dest_uri = 'examples/quick_demo/index.html', page [Page], url = 'examples/quick_demo/', abs_src_path = '/home/bfinley/PhD/igm-doc/docs/examples/quick_demo.md' title str 'Quick Demo' children NoneType None previous_page Page Page(title='Distributed Computing', url='/igm-doc.github.io/2.2.3/hydra/distributed_computing/') next_page Page Page(title='Aletsch Basic', url='/igm-doc.github.io/2.2.3/examples/aletsch_basic/') _Page__active bool False update_date str '2025-03-24' canonical_url str 'https://jouvetg.github.io/igm-doc.github.io/2.2.3/examples/quick_demo/' abs_url str '/igm-doc.github.io/2.2.3/examples/quick_demo/' edit_url str 'https://github.com/jouvetg/igm/edit/master/docs/examples/quick_demo.md' markdown str '{{ macros_info() }}\\n' _title_from_render NoneType None content NoneType None toc list [] meta dict parent Section title = 'Examples', children = [Page(title='Quick Demo', url='/igm-doc.github.io/2.2.3/examples/quick_demo/'), Page(title='Aletsch Basic', url='/igm-doc.github.io/2.2.3/examples/aletsch_basic/')], _Section__active = False, parent [Section] <p>To have all titles of all pages, use:</p> <pre><code>{% for page in navigation.pages %}\n- {{ page.title }}\n{% endfor %}\n</code></pre>"},{"location":"examples/quick_demo/#plugin-filters","title":"Plugin Filters","text":"<p>These filters are provided as a standard by the macros plugin.</p> Variable Type Content pretty function (var_list, rows, header, e) <p>Default Mkdocs-Macro: Prettify a dictionary or object          (used for environment documentation, or debugging).</p> relative_url function (path) <p>Default Mkdocs-Macro:         convert the path of any page according to MkDoc's internal logic,         into a URL relative to the current page         (implements the <code>normalize_url()</code> function from <code>mkdocs.util</code>).         Typically used to manage custom navigation:         <code>{{ page.url | relative_url }}</code>.</p>"},{"location":"examples/quick_demo/#builtin-jinja2-filters","title":"Builtin Jinja2 Filters","text":"<p>These filters are provided by Jinja2 as a standard.</p> <p>See also the Jinja2 documentation on builtin filters.</p> Variable Type Content abs builtin_function_or_method <p>Return the absolute value of the argument.</p> attr function (environment, obj, name, value) <p>Get an attribute of an object.  <code>foo|attr(\"bar\")</code> works like     <code>foo.bar</code> just that always an attribute is returned and items are not     looked up.</p> batch function (value, linecount, fill_with, tmp, item) <p>A filter that batches items. It works pretty much like <code>slice</code>     just the other way round. It returns a list of lists with the     given number of items. If you provide a second parameter this     is used to fill up missing items. See this example.</p> capitalize function (s) <p>Capitalize a value. The first character will be uppercase, all others     lowercase.</p> center function (value, width) <p>Centers the value in a field of a given width.</p> count builtin_function_or_method <p>Return the number of items in a container.</p> d function (value, default_value, boolean) <p>If the value is undefined it will return the passed default value,     otherwise the value of the variable.</p> default function (value, default_value, boolean) <p>If the value is undefined it will return the passed default value,     otherwise the value of the variable.</p> dictsort function (value, case_sensitive, by, reverse, sort_func) <p>Sort a dict and yield (key, value) pairs. Python dicts may not     be in the order you want to display them in, so sort them first.</p> e builtin_function_or_method <p>Replace the characters <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>'</code>, and <code>\"</code> in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML.</p> escape builtin_function_or_method <p>Replace the characters <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>'</code>, and <code>\"</code> in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML.</p> filesizeformat function (value, binary, bytes, base, prefixes, i, prefix, unit) <p>Format the value like a 'human-readable' file size (i.e. 13 kB,     4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega,     Giga, etc.), if the second parameter is set to <code>True</code> the binary     prefixes are used (Mebi, Gibi).</p> first function (args, kwargs, b) <p>Return the first item of a sequence.</p> float function (value, default) <p>Convert the value into a floating point number. If the     conversion doesn't work it will return <code>0.0</code>. You can     override this default using the first parameter.</p> forceescape function (value) <p>Enforce HTML escaping.  This will probably double escape variables.</p> format function (value, args, kwargs) <p>Apply the given values to a <code>printf-style</code>_ format string, like     <code>string % values</code>.</p> groupby function (args, kwargs, b) <p>Group a sequence of objects by an attribute using Python's     :func:<code>itertools.groupby</code>. The attribute can use dot notation for     nested access, like <code>\"address.city\"</code>. Unlike Python's <code>groupby</code>,     the values are sorted first so only one group is returned for each     unique value.</p> indent function (s, width, first, blank, newline, rv, lines) <p>Return a copy of the string with each line indented by 4 spaces. The     first line and blank lines are not indented by default.</p> int function (value, default, base) <p>Convert the value into an integer. If the     conversion doesn't work it will return <code>0</code>. You can     override this default using the first parameter. You     can also override the default base (10) in the second     parameter, which handles input with prefixes such as     0b, 0o and 0x for bases 2, 8 and 16 respectively.     The base is ignored for decimal numbers and non-string values.</p> join function (args, kwargs, b) <p>Return a string which is the concatenation of the strings in the     sequence. The separator between elements is an empty string per     default, you can define it with the optional parameter.</p> last function (environment, seq) <p>Return the last item of a sequence.</p> length builtin_function_or_method <p>Return the number of items in a container.</p> list function (args, kwargs, b) <p>Convert the value into a list.  If it was a string the returned list     will be a list of characters.</p> lower function (s) <p>Convert a value to lowercase.</p> items function (value) <p>Return an iterator over the <code>(key, value)</code> items of a mapping.</p> map function (args, kwargs, b) <p>Applies a filter on a sequence of objects or looks up an attribute.     This is useful when dealing with lists of objects but you are really     only interested in a certain value of it.</p> min function (environment, value, case_sensitive, attribute) <p>Return the smallest item from the sequence.</p> max function (environment, value, case_sensitive, attribute) <p>Return the largest item from the sequence.</p> pprint function (value) <p>Pretty print a variable. Useful for debugging.</p> random function (context, seq) <p>Return a random item from the sequence.</p> reject function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to each object,     and rejecting the objects with the test succeeding.</p> rejectattr function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to the specified     attribute of each object, and rejecting the objects with the test     succeeding.</p> replace function (eval_ctx, s, old, new, count) <p>Return a copy of the value with all occurrences of a substring     replaced with a new one. The first argument is the substring     that should be replaced, the second is the replacement string.     If the optional third argument <code>count</code> is given, only the first     <code>count</code> occurrences are replaced.</p> reverse function (value, rv, e) <p>Reverse the object or return an iterator that iterates over it the other     way round.</p> round function (value, precision, method, func) <p>Round the number to a given precision. The first     parameter specifies the precision (default is <code>0</code>), the     second the rounding method.</p> safe function (value) <p>Mark the value as safe which means that in an environment with automatic     escaping enabled this variable will not be escaped.</p> select function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to each object,     and only selecting the objects with the test succeeding.</p> selectattr function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to the specified     attribute of each object, and only selecting the objects with the     test succeeding.</p> slice function (args, kwargs, b) <p>Slice an iterator and return a list of lists containing     those items. Useful if you want to create a div containing     three ul tags that represent columns.</p> sort function (environment, value, reverse, case_sensitive, attribute, key_func) <p>Sort an iterable using Python's :func:<code>sorted</code>.</p> string builtin_function_or_method <p>Convert an object to a string if it isn't already. This preserves a :class:<code>Markup</code> string rather than converting it back to a basic string, so it will still be marked as safe and won't be escaped again.</p> striptags function (value) <p>Strip SGML/XML tags and replace adjacent whitespace by one space.</p> sum function (args, kwargs, b) <p>Returns the sum of a sequence of numbers plus the value of parameter     'start' (which defaults to 0).  When the sequence is empty it returns     start.</p> title function (s) <p>Return a titlecased version of the value. I.e. words will start with     uppercase letters, all remaining characters are lowercase.</p> trim function (value, chars) <p>Strip leading and trailing characters, by default whitespace.</p> truncate function (env, s, length, killwords, end, leeway, result) <p>Return a truncated copy of the string. The length is specified     with the first parameter which defaults to <code>255</code>. If the second     parameter is <code>true</code> the filter will cut the text at length. Otherwise     it will discard the last word. If the text was in fact     truncated it will append an ellipsis sign (<code>\"...\"</code>). If you want a     different ellipsis sign than <code>\"...\"</code> you can specify it using the     third parameter. Strings that only exceed the length by the tolerance     margin given in the fourth parameter will not be truncated.</p> unique function (environment, value, case_sensitive, attribute, getter, seen, item, key) <p>Returns a list of unique items from the given iterable.</p> upper function (s) <p>Convert a value to uppercase.</p> urlencode function (value, items) <p>Quote data for use in a URL path or query using UTF-8.</p> urlize function (eval_ctx, value, trim_url_limit, nofollow, target, rel, extra_schemes, policies, rel_parts, scheme, rv) <p>Convert URLs in text into clickable links.</p> wordcount function (s) <p>Count the words in that string.</p> wordwrap function (environment, s, width, break_long_words, wrapstring, break_on_hyphens) <p>Wrap a string to the given width. Existing newlines are treated     as paragraphs to be wrapped separately.</p> xmlattr function (eval_ctx, d, autospace, items, key, value, rv) <p>Create an SGML/XML attribute string based on the items in a dict.</p> tojson function (eval_ctx, value, indent, policies, dumps, kwargs) <p>Serialize an object to a string of JSON, and mark it safe to     render in HTML. This filter is only for use in HTML documents.</p>"},{"location":"hydra/configuration/","title":"Hi config","text":""},{"location":"hydra/distributed_computing/","title":"Hi computing","text":""},{"location":"hydra/introduction/","title":"Hi intro","text":""},{"location":"installation/linux/","title":"Linux","text":"<ol> <li>Install NVIDIA drivers</li> </ol> <p>If you aim to use only the CPU or already get an output from <code>nvidia-smi</code>, you can skip this step.</p> <p><pre><code># get the latest libraries from apt\nsudo apt update\nsudo apt upgrade\n\n# choose which driver version is compatible with your GPU device (in this case 510)\nsudo apt install nvidia-driver-510 nvidia-dkms-510\nsudo reboot # you wont see the changes until after you reboot\n</code></pre> After rebooting, you can check your driver version with the command <code>watch -d -n 0.5 nvidia-smi</code> should give you live information on your GPU device.</p> <ol> <li>Install anaconda and create a virtual environment (strongly recommended) with conda or venv:</li> </ol> <pre><code># install anaconda\nwget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh\nbash Anaconda3-2023.09-0-Linux-x86_64.sh\n\n# create new environment\nconda create --name igm python=3.10\n\n# activate environment to install IGM\nconda activate igm\n</code></pre> <p>or</p> <pre><code># create igm venv environment\npython3.10 -m venv igm\n\n# activate environment to install IGM\nsource igm/bin/activate\n</code></pre> <ol> <li>Install IGM</li> </ol> <p>For simple usage, you can install the latest IGM stable version and its dependencies from the Pypi as follows:</p> <pre><code>pip install igm_model\n</code></pre> <p>OR for using all and recent features, you can install the IGM development version from the github repository as follows:</p> <pre><code>git clone https://github.com/jouvetg/igm.git\ncd igm\npip install -e .\n</code></pre> <p>After that, you may run any example (<code>igm_run</code>). As IGM is being updated often, make sure you have the latest version, you may run</p> <pre><code>git pull\n</code></pre>"},{"location":"installation/mac/","title":"Mac","text":"<p>IGM core library native Tensorflow is not supported on Mac for GPU usage. Instead, a \"Tensorflow for Mac\", called tensorflow-metal, was developed as workaround. To install IGM on Mac, you may follow the linux workflow, however, you will need to change in setup.py tensorflow by tensorflow-macos. Here is a working procedure (tested on MacBook Pro M2) -- still we recommend using a virtual environment such as conda or venv as on linux:</p> <p><pre><code>git clone -b develop https://github.com/jouvetg/igm\ncd igm\n</code></pre> You need to edit \"install_requires=[...]\" in the file \"setup.py\":</p> <ul> <li>To use only the CPUs: <code>tensorflow-macos==2.14.0</code></li> <li>To use the GPUs: <code>tensorflow-macos==2.14.0, tensorflow-metal,</code></li> </ul> <p>and then <pre><code>pip install -e .\n</code></pre></p>"},{"location":"installation/quick_start/","title":"Quick Start","text":"<p>This guide serves as the fastest way to install IGM. It assumes that have already</p> <ol> <li>Downloaded the nvidia drivers</li> <li>Have a working virtual environment</li> </ol> <p>If this is the case, you can skip to the next section.</p> <p>Note</p> <p>Tensorflow does not allow us to run IGM on GPU directly on Windows, and the module <code>oggm_shop</code> does not work on windows. Therefore, we recommend windows-user to install WSL2-ubuntu, which provides a linux/ubuntu terminal. WSL2 terminal can be nicely linked with VS code (with an extension). First, install WSL2-ubuntu</p> <pre><code>wsl --install Ubuntu-22.04\nsudo apt update\nsudo apt upgrade\n</code></pre>"},{"location":"installation/quick_start/#installing-methods","title":"Installing Methods","text":"<p>Once this is done, the options are the following</p> <ol> <li>pip</li> <li>github</li> <li>docker</li> </ol>"},{"location":"installation/quick_start/#pip","title":"Pip","text":"<p>To install the latest version of IGM, simply run</p> <pre><code>pip install igm_model\n</code></pre> <p>For reproducibility purposes, one might want to install a specific version of IGM. In order to do this, one can specify the version (note, this version must exist on the PyPI servers).</p> <pre><code>pip install igm_model=='2.2.2'\n</code></pre>"},{"location":"installation/quick_start/#github","title":"Github","text":"<p>If one wants to have the latest versions, or even, work on a specific hash for reproducibility, one can download IGM through the github repository. This is useful for developers, and researchers alike, who want to have the latest features as well as contribute to IGM's model personally.</p> <p>One can download the latest version of IGM with <code>git clone</code></p> <pre><code>git clone https://github.com/jouvetg/igm.git\n</code></pre> <p>Note</p> <p>IGM core library native Tensorflow is not supported on Mac for GPU usage. Instead, a \"Tensorflow for Mac\", called tensorflow-metal, was developed as workaround. To install IGM on Mac, you may follow the linux workflow, however, you will need to change in setup.py tensorflow by tensorflow-macos. Here is a working procedure (tested on MacBook Pro M2) -- still we recommend using a virtual environment such as conda or venv as on linux:</p> <p><pre><code>git clone -b develop https://github.com/jouvetg/igm\ncd igm\n</code></pre> You need to edit \"install_requires=[...]\" in the file \"setup.py\":</p> <ul> <li>To use only the CPUs: <code>tensorflow-macos==2.14.0</code></li> <li>To use the GPUs: <code>tensorflow-macos==2.14.0, tensorflow-metal,</code></li> </ul> <pre><code>cd igm\npip install -e .\n</code></pre> <p>After that, you may run any example (<code>igm_run</code>). As IGM is being updated often, make sure you have the latest version, you may run</p> <pre><code>git pull\n</code></pre>"},{"location":"installation/quick_start/#docker","title":"Docker","text":"<p>For even more granular control, one can opt to use the docker image instead of the github version. This maximizes the chances of reproducibility stability as the virtual environmnet is part of the installation of IGM. ... Assuming you have docker installed already, you can download the docker image through two ways</p> <ol> <li>Docker CLI</li> <li>DockerHub</li> </ol> <p>In order to download IGM through the commandline, you can run the following command</p> <pre><code>docker ...\n</code></pre>"},{"location":"installation/windows/","title":"Windows","text":"<p>Tensorflow does not allow us to run IGM on GPU directly on Windows, and the module <code>oggm_shop</code> does not work on windows. Therefore, we recommend windows-user to install WSL2-ubuntu, which provides a linux/ubuntu terminal. WSL2 terminal can be nicely linked with VS code (with an extension). First, install WSL2-ubuntu</p> <pre><code>wsl --install Ubuntu-22.04\nsudo apt update\nsudo apt upgrade\n</code></pre> <p>and then, install the NVIDIA drivers if not done (if you get no output from <code>nvidia-smi</code>), and if you wish to use the GPU.</p> <p>The rest -- installation of conda or venv environment and the installation of IGM -- are the same as above on Linux.</p>"},{"location":"installation/other/nvidia_drivers/","title":"Nvidia Drivers","text":"<p>If you aim to use only the CPU or already get an output from <code>nvidia-smi</code>, you can skip this step.</p> <p>! Give instructions for the driver version depending on the Tensorflow / GPU version</p> <p><pre><code># get the latest libraries from apt\nsudo apt update\nsudo apt upgrade\n\n# choose which driver version is compatible with your GPU device (in this case 510)\nsudo apt install nvidia-driver-510 nvidia-dkms-510\nsudo reboot # you wont see the changes until after you reboot\n</code></pre> After rebooting, you can check your driver version with the command <code>watch -d -n 0.5 nvidia-smi</code> should give you live information on your GPU device.</p> <p>! Give Photo</p>"},{"location":"installation/other/virtual_environment/","title":"Virtual Environments","text":"<p>Install anaconda and create a virtual environment (strongly recommended) with conda or venv:</p> <pre><code># install anaconda\nwget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh\nbash Anaconda3-2023.09-0-Linux-x86_64.sh\n\n# create new environment\nconda create --name igm python=3.10\n\n# activate environment to install IGM\nconda activate igm\n</code></pre> <p>or one can install a virtual environment without needing to use conda by using the <code>venv</code> module that is built-in to <code>python</code></p> <pre><code># create igm venv environment\npython3.10 -m venv igm\n\n# activate environment to install IGM\nsource igm/bin/activate\n</code></pre>"},{"location":"installation/other/wsl_windows/","title":"WSL Windows","text":"<pre><code>wsl --install Ubuntu-22.04\nsudo apt update\nsudo apt upgrade\n</code></pre> <p>and then, install the NVIDIA drivers if not done (if you get no output from <code>nvidia-smi</code>), and if you wish to use the GPU.</p> <p>The rest -- installation of conda or venv environment and the installation of IGM -- are the same as above on Linux.</p>"},{"location":"modules/introduction/","title":"Introduction","text":"<p>IGM Modules are ...</p>"},{"location":"modules/inputs/load_ncdf/","title":"load_ncdf","text":"<p>This IGM module loads spatial 2D raster data from a NetCDF file (parameter <code>lncd_input_file</code>, default: input.nc) and transform all existing 2D fields into tensorflow variables. It is expected here to import at least basal topography (variable <code>topg</code>). It also complete the data, e.g. the basal topography from ice thickness and surface topography. However, any other field present in NetCDF file will be passed as tensorflow variables, and will therefore be available in the code through <code>state.myvar</code> (e.g. variable <code>icemask</code> can be provided, and served to define an accumulation area -- this is usefull for modelling an individual glaciers, and prevent overflowing in neighbouring catchements). The module also contains the two functions for resampling (parameter <code>lncd_coarsen</code> should be increased to 2,3,4 ..., default 1 value means no coarsening) and cropping the data (parameter <code>lncd_crop</code> should be set to True, and the bounds must be definined as wished).</p> <p>It is possible to restart an IGM run by reading data in an nNetCDF file obtained as a previous IGM run. To that aim, one needs to provide the NETcdf output file as input to IGM. IGM will look for the data that corresponds to the starting time <code>params.time_start</code>, and then intialize it with this time.</p> <p>This module depends on <code>netCDF4</code>.</p>"},{"location":"modules/inputs/load_ncdf/#config-structure","title":"Config Structure","text":"<pre><code>load_ncdf:\n  input_file: input.nc # help=\"NetCDF input data file\"\n  method_coarsen: skipping # help=\"Method for coarsening the data from NetCDF file: skipping or cubic_spline\"\n  coarsen: 1 # help=\"Coarsen the data from NetCDF file by a certain (integer) number: 2 would be twice coarser ignore data each 2 grid points\"\n  crop: False # help=\"Crop the data from NetCDF file with given top/down/left/right bounds\"\n  xmin: -1.0e+20 # help=\"X left coordinate for cropping the NetCDF data\"\n  xmax: 1.0e+20 # help=\"X right coordinate for cropping the NetCDF data\"\n  ymin: -1.0e+20 # help=\"Y bottom coordinate fro cropping the NetCDF data\"\n  ymax: 1.0e+20 # help=\"Y top coordinate for cropping the NetCDF data\"\n  icemask_include: False # help=\"Include ice mask in the NetCDF file\"\n  icemask_shapefile: icemask.shp # help=\"Shapefile for ice mask\"\n  icemask_invert: False # help=\"Invert the ice mask\"\n</code></pre>"},{"location":"modules/inputs/load_ncdf/#parameters","title":"Parameters","text":"Name Type Units Description Default Value input_file str file path NetCDF input data file input.nc method_coarsen str string Method for coarsening the data from NetCDF file (skipping or cubic_spline) skipping coarsen int integer Coarsen the data from NetCDF file by a certain (integer) number (2 would be twice coarser ignore data each 2 grid points) 1 crop bool boolean Crop the data from NetCDF file with given top/down/left/right bounds False xmin float float X left coordinate for cropping the NetCDF data -1e+20 xmax float float X right coordinate for cropping the NetCDF data 1e+20 ymin float float Y bottom coordinate for cropping the NetCDF data -1e+20 ymax float float Y top coordinate for cropping the NetCDF data 1e+20 icemask_include bool boolean Include ice mask in the NetCDF file False icemask_shapefile str file path Shapefile for ice mask icemask.shp icemask_invert bool boolean Invert the ice mask False <p>--&gt;</p>"},{"location":"modules/inputs/load_ncdf/#example-usage","title":"Example Usage","text":""},{"location":"modules/inputs/load_tif/","title":"load_tif","text":"<p>This IGM module loads spatial 2D raster data from any tif file present in the working directory folder, and transform each of them into tensorflow variables, the name of the file becoming the name of the variable, e.g. the file topg.tif will yield variable topg, ect... It is expected here to import at least basal topography (variable <code>topg</code>). It also complete the data, e.g. the basal topography from ice thickness and surface topography. Note that all these variables will therefore be available in the code with <code>state.myvar</code> from myvar.tif (e.g. variable <code>icemask</code> can be provided, and served to define an accumulation area -- this is usefull for modelling an individual glaciers, and prevent overflowing in neighbouring catchements). The module also contains two functions for resampling (parameter <code>ltif_coarsen</code> should be increased to 2,3,4 ..., default 1 value means no coarsening) and cropping the data (parameter <code>ltif_crop</code> should be set to True, and the bounds must be definined as wished).</p> <p>This module depends on <code>rasterio</code>.</p>"},{"location":"modules/inputs/load_tif/#config-structure","title":"Config Structure","text":"<pre><code>load_tif:\n  coarsen: 1 # help=\"coarsen the data to a coarser resolution (default: 1), e.g. 2 would be twice coarser ignore data each 2 grid points\"\n  crop: False # help=\"Crop the data with xmin, xmax, ymin, ymax (default: False)\"\n  xmin: -1.0e+20 # help=\"crop_xmin\" \n  xmax: 1.0e+20 # help=\"crop_xmax\"\n  ymin: -1.0e+20 # help=\"crop_ymin\"\n  ymax: 1.0e+20 # help=\"crop_ymax\"\n  folder: \"\" # help=\"folder\"\n  icemask_include: False # help=\"Include ice mask in the NetCDF file\"\n  icemask_shapefile: icemask.shp # help=\"Shapefile for ice mask\"\n  icemask_invert: False # help=\"Invert the ice mask\"\n</code></pre>"},{"location":"modules/inputs/load_tif/#parameters","title":"Parameters","text":"Name Type Units Description Default Value coarsen int integer Coarsen the data from NetCDF file by a certain (integer) number (2 would be twice coarser ignore data each 2 grid points) 1 crop bool boolean Crop the data from NetCDF file with given top/down/left/right bounds False xmin float float Crop the data from NetCDF file with the given minimum x bound -1e+20 xmax float float Crop the data from NetCDF file with the given maximum x bound 1e+20 ymin float float Crop the data from NetCDF file with the given minimum y bound -1e+20 ymax float float Crop the data from NetCDF file with the given maximum y bound 1e+20 folder str file path Folder containing the tif files icemask_include bool boolean Include ice mask in the NetCDF file False icemask_shapefile str file path Shapefile for ice mask icemask.shp icemask_invert bool boolean Invert the ice mask False"},{"location":"modules/inputs/load_tif/#example-usage","title":"Example Usage","text":""},{"location":"modules/inputs/oggm_shop/","title":"oggm_shop","text":"<p>This IGM module uses OGGM utilities and GlaThiDa dataset to prepare data  for the IGM model for a specific glacier given the RGI ID (parameter <code>oggm_RGI_ID</code>), check at GLIMS VIeWER to find the RGI ID of your glacier (only for RGI 6.0 - if using RGI 7.0, please download the RGI shapefiles and use the enquire function in your GIS software to find the right ID - by default, IGM looks at RGI 7.0C here. but modifying line 304 of the module to '70G' instead of '70C' will give you that version instead. This may be made a parameter in the future once the RGI 7.0 release and associated OGGM data are all finalised). By default, data are already processed (parameter <code>oggm_preprocess</code> is True), with spatial resolution of 100 m and an oggm_border size of 30 m. For custom spatial resolution and size of 'oggm_border' to keep a safe distance to the glacier margin, one need to set <code>oggm_preprocess</code> parameter to False, and set <code>oggm_dx</code> and <code>oggm_border</code> parameter as desired. </p> <p>The module directly provides IGM with all 2D gridded variables (as tensorflow object), and are accessible in the code with e.g. <code>state.thk</code>. By default a copy of all the data are stored in a NetCDF file <code>input_saved.nc</code> so that this file can be readed directly in a second run with module <code>load_ncdf</code> instead of re-downloading the data with <code>oggm_shop</code> again. The module provides all data variables necessary to run IGM for a forward glacier evolution run (assuming we provide basal topography <code>topg</code> and ice thickness <code>thk</code>), or a preliminary data assimilation/ inverse modelling with the <code>optimize</code> module further data (typically <code>icemaskobs</code>, <code>thkinit</code>, <code>uvelsurf</code>, <code>vvelsurf</code>, <code>thkobs</code>, <code>usurfobs</code>).</p> <p>Data are currently based on COPERNICUS DEM 90 for the top surface DEM, the surface ice velocity from (Millan, 2022), the ice thickness from (Millan, 2022) or (farinotti2019) (the user can choose with parameter <code>oggm_thk_source</code> between <code>millan_ice_thickness</code> or <code>consensus_ice_thickness</code> dataset). </p> <p>When activating <code>oggm_include_glathida</code> to True, ice thickness profiles are downloaded from the GlaThiDa depo and are rasterized with name <code>thkobs</code> (pixels without data are set to NaN values.) if using RGI 6.0. With RGI 7.0, the GlaThiDa data are downloaded for the specific glacier (defined by the RGI ID) from the OGGM server and are found as a text file in the download folder created by this module (glathida_data.csv), from where they are subsequently read in, rasterised, and NaNs added where there are no observations.</p> <p>The OGGM script was written by Fabien Maussion. The GlaThiDa script was written by Ethan Welty &amp; Guillaume Jouvet. RGI 7.0 modifications were written by Samuel Cook.</p> <p>The module depends (of course) on the <code>oggm</code> library. Unfortunately the module works on linux and Max, but not on windows (unless using WSL).</p>"},{"location":"modules/inputs/oggm_shop/#config-structure","title":"Config Structure","text":"<pre><code>oggm_shop:\n  RGI_ID: \"RGI60-11.01450\" # help=\"RGI ID\"\n  preprocess: True # help=\"Use preprocessing\"\n  RGI_version: 7 # help=\"this is temporary fix, is 6 or 7\"\n  dx: 100 # help=\"Spatial resolution (need preprocess false to change it)\"\n  border: 30 # help=\"Safe border margin  (need preprocess false to change it)\"\n  thk_source: consensus_ice_thickness # help=\"millan_ice_thickness or consensus_ice_thickness\"\n  vel_source: millan_ice_velocity # help=\"Source of the surface velocities (millan_ice_velocity or its_live)\"\n  incl_glathida: False # help=\"Make observation file (for IGM inverse)\"\n  path_glathida: \"\" # help=\"Path where the Glathida Folder is stored, so that you don't need to redownload it at every use of the script, if empty it will be in the home directory (only relevant for RGI6.0)\",\n  save_in_ncdf: True # help=\"Write prepared data into a geology file\"\n  remove_RGI_folder: True # help=\"remove_RGI_folder\"\n  sub_entity_mask: False # help=\"Ice mask shows individual RGI 7.0G entities within each larger RGI 7.0C complex\"\n  RGI_product: \"G\" # help=\"Glacier complexes (C) or individual basins (G) (default is G, individual basins)\"\n  run_batch: False # help=\"Run all the glaciers in the world\"\n  smooth_obs_vel: True # help=\"Smooth the observed velocities\"\n\n# ===================== NOTE =====================\n# aletsch  RGI60-11.01450\n# malspina RGI60-01.13696\n# brady    RGI60-01.20796\n# ethan    RGI60-01.00709\n# ================================================\n</code></pre>"},{"location":"modules/inputs/oggm_shop/#parameters","title":"Parameters","text":"Name Type Units Description Default Value RGI_ID str string RGI ID RGI60-11.01450 preprocess bool boolean Use preprocessing True RGI_version int integer This is a temporary fix, is 6 or 7 7 dx int integer Spatial resolution (need preprocess false to change it) 100 border int integer Safe border margin (need preprocess false to change it) 30 thk_source str string Millan ice thickness or consensus ice thickness consensus_ice_thickness vel_source str string Source of the surface velocities (millan_ice_velocity or its_live) millan_ice_velocity incl_glathida bool boolean Make observation file (for IGM inverse) False path_glathida str file path Path where the Glathida Folder is stored, so that you don't need to redownload it at every use of the script, if empty it will be in the home directory (only relevant for RGI6.0) save_in_ncdf bool boolean Write prepared data into a geology file True remove_RGI_folder bool boolean Remove RGI folder True sub_entity_mask bool boolean Ice mask shows individual RGI 7.0G entities within each larger RGI 7.0C complex False RGI_product str string Glacier complexes (C) or individual basins (G) (default is G, individual basins) G run_batch bool boolean Run all the glaciers in the world False smooth_obs_vel bool boolean Smooth the observed velocities True"},{"location":"modules/inputs/oggm_shop/#example-usage","title":"Example Usage","text":""},{"location":"modules/outputs/plot2d/","title":"plot2d","text":"<p>This IGM module produces 2D plan-view plots of variable defined by parameter <code>plt2d_var</code> (e.g. <code>plt2d_var</code> can be set to <code>thk</code>, or <code>ubar</code>, ...). The saving frequency is given by parameter <code>time_save</code> defined in module <code>time</code>.  The scale range of the colobar is controlled by parameter <code>plt2d_varmax</code>.</p> <p>By default, the plots are saved as png files in the working directory. However, one may display the plot \"in live\" by setting <code>plt2d_live</code> to True. Note that if you use the spyder python editor, you need to turn <code>plt2d_editor</code> to 'sp'.</p> <p>If the <code>particles</code> module is activated, one may plot particles on the top setting <code>plt2d_particles</code> to True, or remove them form the plot seeting it to False.</p>"},{"location":"modules/outputs/plot2d/#config-structure","title":"Config Structure","text":"<pre><code>plot2d:\n  editor: vs # help=\"Optimized for VS code (vs) or spyder (sp) for live plot\"\n  live: False # help=\"Display plots live the results during computation instead of making png\"\n  particles: True # help=\"Display particles is True, does not display if False\"\n  var: \"velbar_mag\" # help=\"Name of the variable to plot\"\n  var_max: 1000 # help=\"Maximum value of the varplot variable used to adjust the scaling of the colorbar\"\n</code></pre>"},{"location":"modules/outputs/plot2d/#parameters","title":"Parameters","text":"Name Type Units Description Default Value editor str string Optimized for VS code (vs) or spyder (sp) for live plot vs live bool boolean Display plots live the results during computation instead of making png False particles bool boolean Display particles is True, does not display if False True var str string Name of the variable to plot velbar_mag var_max float float Maximum value of the varplot variable used to adjust the scaling of the colorbar 1000"},{"location":"modules/outputs/plot2d/#example-usage","title":"Example Usage","text":""},{"location":"modules/outputs/write_ncdf/","title":"write_ncdf","text":"<p>This IGM module writes 2D field variables defined in the paramer list <code>wncd_vars_to_save</code> into the NetCDF output file given by parameter <code>wncd_output_file</code> (default output.nc). The saving frequency is given by parameter <code>time_save</code> defined in module <code>time</code>.</p>"},{"location":"modules/outputs/write_ncdf/#config-structure","title":"Config Structure","text":"<pre><code>write_ncdf:\n  output_file: output.nc # help=\"Output ncdf data file\"\n  vars_to_save: # help=\"List of variables to be recorded in the ncdf file\"\n    - topg\n    - usurf\n    - thk\n    - smb\n    - velbar_mag\n    - velsurf_mag\n    - uvelsurf\n    - vvelsurf\n    - wvelsurf\n</code></pre>"},{"location":"modules/outputs/write_ncdf/#parameters","title":"Parameters","text":"Name Type Units Description Default Value output_file str file path Output ncdf data file output.nc vars_to_save list None List of variables to be recorded in the ncdf file ['topg', 'usurf', 'thk', 'smb', 'velbar_mag', 'velsurf_mag', 'uvelsurf', 'vvelsurf', 'wvelsurf']"},{"location":"modules/outputs/write_ncdf/#example-usage","title":"Example Usage","text":""},{"location":"modules/outputs/write_particles/","title":"write_particles","text":"<p>This IGM module writes particle time-position in csv files computed by module <code>particles</code>. The saving frequency is given by parameter <code>time_save</code> defined in module <code>time</code>.</p> <p>The data are stored in folder 'trajectory' (created if does not exist). Files 'traj-TIME.csv' reports the space-time position of the particles at time TIME with the following structure:</p> <pre><code>ID,  state.xpos,  state.ypos,  state.zpos, state.rhpos,  state.tpos, state.englt\nX,            X,           X,           X,           X,           X,           X,\nX,            X,           X,           X,           X,           X,           X,\nX,            X,           X,           X,           X,           X,           X,\n</code></pre> <p>providing in turn the particle ID, x,y,z positions, the relative height within the ice column, the seeding time, and the englacial time.</p>"},{"location":"modules/outputs/write_particles/#config-structure","title":"Config Structure","text":"<pre><code>write_particles:\n    add_topography: True # help=\"Add topg\"\n</code></pre>"},{"location":"modules/outputs/write_particles/#parameters","title":"Parameters","text":"Name Type Units Description Default Value add_topography bool boolean Add topography True"},{"location":"modules/outputs/write_particles/#example-usage","title":"Example Usage","text":""},{"location":"modules/outputs/write_tif/","title":"write_tif","text":"<p>This IGM module writes 2D field variables defined in the paramer list <code>wtif_vars_to_save</code> into tif output files. Files will be created with names composed by the variable name and the time (e.g., thk-000040.tif, usurf-000090.tif) in the working directory. The saving frequency is given by parameter <code>time_save</code> defined in module <code>time</code>. If input file were call with module <code>load_tif</code>, then the tif meta information are saved, and provided with the final tiff files.</p> <p>This module depends on the <code>rasterio</code> library.</p>"},{"location":"modules/outputs/write_tif/#config-structure","title":"Config Structure","text":"<pre><code>write_tif:\n  vars_to_save: # help=\"List of variables to be saved as geotiff files\"\n      - usurf\n      - thk\n</code></pre>"},{"location":"modules/outputs/write_tif/#parameters","title":"Parameters","text":"Name Type Units Description Default Value vars_to_save list None List of variables to be saved as geotiff files ['usurf', 'thk']"},{"location":"modules/outputs/write_tif/#example-usage","title":"Example Usage","text":""},{"location":"modules/outputs/write_ts/","title":"write_ts","text":"<p>This IGM module writes time serie variables (ice glaciated area and volume) into the NetCDF output file defined by parameter <code>wts_output_file</code> (default output_ts.nc). The saving frequency is given by parameter <code>time_save</code> defined in module <code>time</code>.</p>"},{"location":"modules/outputs/write_ts/#config-structure","title":"Config Structure","text":"<pre><code>write_ts:\n  output_file: output_ts.nc # help=\"Output ncdf data file (time series)\"\n</code></pre>"},{"location":"modules/outputs/write_ts/#parameters","title":"Parameters","text":"Name Type Units Description Default Value output_file str file path Output ncdf data file (time series) output_ts.nc"},{"location":"modules/outputs/write_ts/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/avalanche/","title":"Avalanche","text":"<p>This IGM module permits to model redistribution of snow due to avalanches. This routine move ice/snow downslope until the ice surface is everywhere at angle of repose. This function was adapted from  Mark Kessler's GC2D program and implemented in IGM by J\u00fcrgen Mey with support from Guillaume Jouvet.</p>"},{"location":"modules/processes/avalanche/#config-structure","title":"Config Structure","text":"<pre><code>avalanche:\n  update_freq: 1 # help=\"Update avalanche each X years (1)\"\n  angleOfRepose: 30.0 # help=\"Angle of repose (30\u00b0)\"\n</code></pre>"},{"location":"modules/processes/avalanche/#parameters","title":"Parameters","text":"Name Type Units Description Default Value update_freq float years Frequency at which to update the avalanche module 1 angleOfRepose float Degrees Angle of repose 30.0"},{"location":"modules/processes/avalanche/#example-usage","title":"Example Usage","text":"<p>We can run a simulation with a higher frequency of avalanches by changing the <code>avalanche_update_freq</code> argument. We can either do this in our config file.</p> <p>params.yaml<pre><code># @package _global_\n\ncore:\n  url_data: https://www.dropbox.com/scl/fo/kd7dix5j1tm75nj941pvi/h?rlkey=q7jtmf9yn3a970cqygdwne25j&amp;dl=0\n\nmodules:\n  load_ncdf:\n    lncd_input_file: data/input.nc\n  smb_simple:\n    smb_simple_array:\n      - [\"time\", \"gradabl\", \"gradacc\", \"ela\", \"accmax\"]\n      - [1900, 0.009, 0.005, 2800, 2.0]\n      - [2000, 0.009, 0.005, 2900, 2.0]\n      - [2100, 0.009, 0.005, 3300, 2.0]\n  time_igm:\n    time_start: 1900.0\n    time_end: 2000.0\n    time_save: 10.0\n  avalanche:\n    avalanche_update_freq: 5 # every 5 years\n</code></pre> Alternatively, we can do it over the command line <pre><code>igm_run +experiment/params modules.avalanche.avalanche_update_freq=5\n</code></pre></p>"},{"location":"modules/processes/clim_oggm/","title":"clim_oggm","text":"<p>Module <code>clim_oggm</code> reads monthly time series of historical GSWP3_W5E5 climate data collected by the <code>oggm_shop</code> module, and generates monthly 2D raster fields of corrected precipitation, mean temperature, and temperature variability. To achieve this, we first apply a multiplicative correction factor for precipitation (parameter <code>prcp_fac</code>) and a biais correction for temperature (parameter <code>temp_bias</code>). Then, the module extrapolates temperature data to the entire glacier surface using a reference height and a constant lapse rate (parameter <code>temp_default_gradient</code>). In constrast, the point-wise data for precipitation and temperature variablity are extended to the entire domain without further correction. Module <code>oggm_shop</code> provides all calibrated parameters. The resulting fields are intended to be used to force the surface mass balance or enthalpy models.</p>"},{"location":"modules/processes/clim_oggm/#config-structure","title":"Config Structure","text":"<pre><code>clim_oggm:\n  update_freq: 1 # help=\"Update the climate each X years\"\n  file: file.txt # help=\"Name of the imput file for the climate outide the given datatime frame (time, delta_temp, prec_scali)\"\n  clim_trend_array: # help=\"Define climate trend outside available time window\"\n    - [\"time\", \"delta_temp\", \"prec_scal\"]\n    - [1900, 0.0, 1.0]\n    - [2020, 0.0, 1.0]\n  ref_period: [1960, 1990] # help=\"Define the reference period to pick year outside available time window\"\n  seed_par: 123 # help=\"Seeding parameter to fix for pickying randomly yer in the ref period\"\n</code></pre>"},{"location":"modules/processes/clim_oggm/#parameters","title":"Parameters","text":"<p>Here we store a table with</p> Name Type Units Description Default Value update_freq float years Update the climate each X years 1 file string string Name of the input file for the climate outside the given datetime frame (time, delta_temp, prec_scaling) file.txt clim_trend_array list list Define climate trend outside available time window [['time', 'delta_temp', 'prec_scal'], [1900, 0.0, 1.0], [2020, 0.0, 1.0]] ref_period list list Define the reference period to pick year outside available time window [1960, 1990] seed_par integer integer Seeding parameter to fix for picking randomly year in the ref period 123 <p>--&gt;</p>"},{"location":"modules/processes/clim_oggm/#example-usage","title":"Example Usage","text":"<p>We can run a simulation with a higher frequency of avalanches by changing the ... argument. We can either do this in our config file.</p> <p>params.yaml<pre><code># @package _global_\n\ncore:\n  url_data: https://www.dropbox.com/scl/fo/kd7dix5j1tm75nj941pvi/h?rlkey=q7jtmf9yn3a970cqygdwne25j&amp;dl=0\n\nmodules:\n  load_ncdf:\n    lncd_input_file: data/input.nc\n  smb_simple:\n    smb_simple_array:\n      - [\"time\", \"gradabl\", \"gradacc\", \"ela\", \"accmax\"]\n      - [1900, 0.009, 0.005, 2800, 2.0]\n      - [2000, 0.009, 0.005, 2900, 2.0]\n      - [2100, 0.009, 0.005, 3300, 2.0]\n  time_igm:\n    time_start: 1900.0\n    time_end: 2000.0\n    time_save: 10.0\n  clim_oggm:\n    smb_oggm_file: my_smb_oggm_param.txt\n    clim_oggm_clim_trend_array:\n        - [\"time\", \"delta_temp\", \"prec_scal\"]\n        - [1500, 0.0, 1.0]\n        - [2720, 0.0, 1.0]\n</code></pre> Alternatively, we can do it over the command line <pre><code>igm_run +experiment/params modules.avalanche.smb_oggm_file=my_smb_oggm_param.txt\n</code></pre></p>"},{"location":"modules/processes/clim_oggm/#climate-outside-the-time-frame-of-available-data","title":"Climate outside the time frame of available data","text":"<p>In addition, this module can generate climate outside the time frame of available data. To that aim, we define a reference period with parameter <code>clim_oggm_ref_period</code> to pick randomly years within this interval (usually taken to be a climate-neutral period), and apply a biais in temperature and a scaling of precipitation. These parameters may be given in file (file name given in <code>clim_oggm_file</code> parameter), which look like this (this example gives an linear increase of temperature of 4 degrees by the end of 2100 (with respect to the period 1960-1990):</p> <pre><code>time   delta_temp  prec_scal\n1900          0.0        1.0\n2020          0.0        1.0\n2100          4.0        1.0\n</code></pre> <p>or directly as parameter in the config <code>params.json</code> file:</p> <pre><code>\"clim_oggm_clim_trend_array\": [ \n                     [\"time\", \"delta_temp\", \"prec_scal\"],\n                     [ 1900,           0.0,         1.0],\n                     [ 2020,           0.0,         1.0],\n                     [ 2100,           4.0,         1.0]\n                              ],  \n</code></pre> <p>If parameter <code>clim_oggm_clim_trend_array</code> is set to empty list <code>[]</code>, then it will read the file <code>clim_oggm_file</code>, otherwise it read the array <code>clim_oggm_clim_trend_array</code> (which is here in fact a list of list).</p>"},{"location":"modules/processes/enthalpy/","title":"enthalpy","text":"<p>This IGM module models the ice enthalpy, which permits to jointly model the ice temperature, as well as the water content created when the temperature hits the pressure melting points, and therefore energy conservation, which is not the case when modelling the sole temperature variable. The model is described in (Aschwanden and al, JOG, 2012). Here, we used a simplified version largely inspired from the one implemented in PISM. Other references that have helped are (Kleiner and al, TC, 2015) and (Wang and al, 2020).</p>"},{"location":"modules/processes/enthalpy/#config-structure","title":"Config Structure","text":"<pre><code>enthalpy:\n  water_density: 1000.0 # help=\"Constant of the Water density [kg m-3]\",\n  spy: 31556926.0 # help=\"Number of seconds per years [s y-1]\",\n  ki: 2.1 # help=\"Conductivity of cold ice [W m-1 K-1] (Aschwanden and al, JOG, 2012)\",\n  ci: 2009.0 # help=\"Specific heat capacity of ice [W s kg-1 K-1] (Aschwanden and al, JOG, 2012)\",\n  Lh: 3.34e+5 # help=\"latent heat of fusion [W s kg-1] = [E] (Aschwanden and al, JOG, 2012)\",\n  KtdivKc: 1e-1 # help=\"Ratio of temp vs cold ice diffusivity Kt / Kc [no unit] (Aschwanden and al, JOG, 2012)\",\n  claus_clape: 7.9e-8 # help=\"Clausius-Clapeyron constant [K Pa-1] (Aschwanden and al, JOG, 2012)\",\n  melt_temp: 273.15 # help=\"Melting point at standart pressure [K] (Aschwanden and al, JOG, 2012)\",\n  ref_temp: 223.15 # help=\"Reference temperature [K] (Aschwanden and al, JOG, 2012)\",\n  till_friction_angle: 30.0 # help=\"Till friction angle in the Mohr-Coulomb friction law [deg]\",\n  till_friction_angle_bed_min: null # help=\"till_friction_angle_bed_min\",\n  till_friction_angle_bed_max: null # help=\"till_friction_angle_bed_max\",\n  till_friction_angle_phi_min: 15.0 # help=\"till_friction_angle_phi_min\",\n  till_friction_angle_phi_max: 45.0 # help=\"till_friction_angle_phi_max\",\n  uthreshold: 100.0 # help=\"uthreshold [m/y] # \"--uthreshold\", type=float, default=100, help=\"uthreshold [m/y]\"\n  drain_rate: 0.001 # help=\"Drain rate at 1 mm/y  [m y-1] (Bueler and Pelt, GMD, 2015)\",\n  till_wat_max: 2.0 # help=\"Maximum water till tickness [m] (Bueler and Pelt, GMD, 2015)\",\n  drain_ice_column: True # help=\"Transform the water content beyond a thr=0.01 into water, drain it, and add it to basal melt rate\",\n  default_bheatflx: 0.065 # help=\"Geothermal heat flux [W m-2]\",\n  temperature_offset_air_to_ice: 0.0 # help=\"This is the offset between the air temperature and the ice temperature as records show [e.g., Reeh 1991] shows that the mean temperature at the ice surface is about X\u00b0C colder than the temperature of ice to be given as boundary upper condition to the Enthlapy model\",\n  tauc_min: 1.0e+5 # help=\"lower bound for tauc [Pa]\"\n  tauc_max: 1.0e+10 # help=\"lower bound for tauc [Pa]\"\n</code></pre>"},{"location":"modules/processes/enthalpy/#parameters","title":"Parameters","text":"Name Type Units Description Default Value water_density float $$kg~m^{-3}$$ Constant of the Water density 1000.0 spy float $$s y^{-1}$$ Number of seconds per years 31556926.0 ki float ['W m-1 K-1'] Conductivity of cold ice (Aschwanden and al, JOG, 2012) 2.1 ci float ['W s kg-1 K-1'] Specific heat capacity of ice (Aschwanden and al, JOG, 2012) 2009.0 Lh float [W s kg-1] = [E] Latent heat of fusion (Aschwanden and al, JOG, 2012) 334000.0 KtdivKc float Kt / Kc [no unit] Ratio of temp vs cold ice diffusivity (Aschwanden and al, JOG, 2012) 1e-1 claus_clape float ['K Pa-1'] Clausius-Clapeyron constant (Aschwanden and al, JOG, 2012) 7.9e-08 melt_temp float ['K'] Melting point at standard pressure (Aschwanden and al, JOG, 2012) 273.15 ref_temp float ['K'] Reference temperature (Aschwanden and al, JOG, 2012) 223.15 till_friction_angle float ['deg'] Till friction angle in the Mohr-Coulomb friction law 30.0 till_friction_angle_bed_min float ['deg'] Minimum till friction angle at the bed None till_friction_angle_bed_max float ['deg'] Maximum till friction angle at the bed None till_friction_angle_phi_min float ['deg'] Minimum till friction angle phi 15.0 till_friction_angle_phi_max float ['deg'] Maximum till friction angle phi 45.0 uthreshold float ['m/y'] Threshold velocity 100.0 drain_rate float ['m y-1'] Drain rate at 1 mm/y (Bueler and Pelt, GMD, 2015) 0.001 till_wat_max float ['m'] Maximum water till thickness (Bueler and Pelt, GMD, 2015) 2.0 drain_ice_column float ['m'] Transform the water content beyond a threshold into water, drain it, and add it to basal melt rate True default_bheatflx float ['W m-2'] Geothermal heat flux 0.065 temperature_offset_air_to_ice float ['K'] Offset between the air temperature and the ice temperature 0.0 tauc_min float ['Pa'] Lower bound for tauc 100000.0 tauc_max float ['Pa'] Upper bound for tauc 10000000000.0"},{"location":"modules/processes/enthalpy/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/enthalpy/#theory","title":"Theory","text":""},{"location":"modules/processes/enthalpy/#ice-flow","title":"Ice flow","text":"<p>Here we only quickly sketch the components of the ice dynamical modelling necessary for modeling the Enthalpy.</p> <p>Ice is assumed to be a Non Newtonian fluid, gouverned by Glen's flow law:</p> \\[ \\tau = A^{-1/n} | D({\\bf u}) |^{1/n-1} D({\\bf u}), \\] <p>where \\(D({\\bf U})\\) and \\(\\tau\\) are the strain rate and deviatoric stress tensor, respectively. While a no-stress condition is applied on the top surface, we assume that the basal shear stress  \\(\\tau_b\\) and the sliding velocity \\(u_b\\) are linked by Weertmann power law at the glacier bed interface:</p> \\[  \\tau_b = - c | u_b |^{m-1} u_b, \\] <p>where \\(c=\\tau_c u_{th}^{-m}\\) (unit: \\(Mpa \\; m^{-m} \\; y^m\\)), \\(\\tau_c\\) being the yield stress and \\(u_{th}\\) being a parameter homegenous to ice velocity. This formalism is taken from PISM.</p> <p>(Note that originally, IGM had \\(c^{-m}\\) instead of \\(c\\) above as \"slidingco\" with \\(u_{th}=1\\). The newest runs under parameters \"new_sliding_param\", and \\(c\\) has unit \\(MPa \\; m^{-m} \\; y^m\\))</p>"},{"location":"modules/processes/enthalpy/#enthalpy_1","title":"Enthalpy","text":"<p>The Enthalpy \\(E\\) is a 3D variable defined everywhere in the ice as a function of the temperature \\(T\\) and the water content \\(\\omega\\):</p> \\[ \\begin{align} E(T, \\omega,p) =  \\left\\{ \\begin{array}{ll} c_i (T- T_{\\rm ref}), &amp; {\\rm  if } \\; T &lt; T_{\\rm pmp} , \\\\  E_{\\rm pmp} + L \\omega, &amp;   {\\rm if } \\;  T = T_{\\rm pmp} \\; {\\rm and } \\; 0 \\le \\omega, \\end{array}  \\right.   \\end{align} \\] <p>where \\(c_i\\) is the heat capacity, \\(T_{ref}\\) is the reference temperature, \\(T_{\\rm pmp} = T_{\\rm pmp}(p) = T_0 - \\beta p\\) is the temperature pressure-melting point of ice, \\(E_{\\rm pmp}(p)\\)  is the enthalpy pressure-melting point of ice defined as </p> \\[ E_{\\rm pmp}(p) = c_i (T_{\\rm pmp}(p) - T_{\\rm ref}), \\] <p>where \\(L\\) is the latent heat of fusion. According to the above defintion of enthalpy, we have two possible modes: i) the ice is cold, i.e. below the melting point, and the Enthalpy is simply proportional to the temperature minus a reference temperature ii) the ice is temperate and the Enthalpy continue to grow, the additional component \\(L \\omega\\) corresponding to the creation of water content by energy transfer. Therefore, it is straightforward to deduce \\(E\\) from \\(T\\) and \\(\\omega\\).</p> <p>The enthalpy model consists of the following advection-diffusion equation (the horizontal diffusion being neglected):</p> \\[  \\begin{align} &amp; \\rho_i \\left( \\frac{\\partial E}{ \\partial t} + u_x \\frac{\\partial E}{ \\partial x} + u_y \\frac{\\partial E}{ \\partial y}  + u_z \\frac{\\partial E}{ \\partial z} \\right)   - \\frac{\\partial }{\\partial z} \\left( K_{c,t} \\frac{\\partial E}{ \\partial z} \\right) = \\phi - \\rho_w L D_w(\\omega), \\end{align} \\] <p>where \\(\\rho_i\\) is the ice density, \\(K_{c,t}\\) equals \\(K_c = k_i/c_i\\) if the ice is cold (\\(E&lt;E_{pmp}\\)) or \\(K_t = \\epsilon k_i/c_i\\) otherwise, \\(\\phi\\) is the strain heating defined by (using Glen's flow law)</p> \\[ \\phi = D({\\bf U}) \\tau = A^{-1/n} | D({\\bf u}) |^{1+1/n}, \\] <p>where \\(D({\\bf U})\\) and \\(\\tau\\) are the strain rate and deviatoric stress tensor, respectively. The last source term \\(- \\rho_w L D_w(\\omega)\\)  permits to remove the water in temperate ice \\(D_w(\\omega)\\) being a drainage function ((Greve, 1997) and (Aschwanden et al., 2012)).</p> <p>At the top ice surface, the enthalpy equation is constrained by the surface temperature (or equivalently the Enthalpy) provided by the climate forcing (Dirichlet condition). At the glacier bed, boundary conditions for the enthalpy equation are multiple ((Aschwanden and al, JOG, 2012), (Kleiner and al, TC, 2015) and (Wang and al, 2020).)</p> <ul> <li>\\(K_{c} \\frac{\\partial E}{ \\partial z} = Q_{\\rm geo} + Q_{\\rm fh}\\) if \\(E_b&lt;E_{\\rm pmp}\\) and \\(H_w = 0\\), (cold base, dry) </li> <li>\\(E_b = E_{\\rm pmp}\\) if \\(E_b&lt;E_{\\rm pmp}\\) and \\(H_w &gt; 0\\), (cold base, wet)</li> <li>\\(E_b = E_{\\rm pmp}\\) if \\(E_b \\ge E_{\\rm pmp}\\) and \\(W_{till}&gt; 0\\), zero temperate basal layer, (temperate base, cold ice)</li> <li>\\(K_{t} \\frac{\\partial E}{ \\partial z} = 0\\) if \\(E_b \\ge E_{\\rm pmp}\\) and \\(W_{till} &gt; 0\\), non-zero temperate basal layer, (temperate base, temp. ice)</li> </ul> <p>where \\(H_t\\) is the height of the temperate basal layer, \\(Q_{\\rm geo}\\) and \\(Q_{\\rm fh}\\) are the geothermal heat flux, and the frictional heat flux, respectively. The latter is defined by </p> \\[  Q_{\\rm fh} = \\tau_b \\cdot u_b = c | u_b |^{m+1}. \\] <p>As a matter of fact, the ice enthalpy (or equivalently temperature and water content) feedbacks the dynamical model in two ways. The Enthalpy directly impacts the sliding basal parametrization, while variations in temperature and water content cause ice softening or hardening. </p>"},{"location":"modules/processes/enthalpy/#basal-melt","title":"Basal melt","text":"<p>When the temperature hits the pressure-melting point at the glacier bed (i.e. \\(E \\ge E_{\\rm pmp}\\)), the basal melt rate is calculated via the following equation:</p> \\[ \\begin{equation} m_b = \\frac{Q_{fr}+Q_{geo} - K_{t,c} \\frac{\\partial E}{ \\partial z} }{\\rho_i L}.  \\end{equation} \\] <p>The basal melt rate is further adjusted positively to account for the drainage of the water content generated along the entire column.</p>"},{"location":"modules/processes/enthalpy/#water-thickness","title":"Water thickness","text":"<p>The basal water thickness in the till \\(W_{till}\\) is computed directly from the basal melt rate as follows:</p> \\[ \\begin{equation} \\frac{\\partial W_{till} }{ \\partial z} = \\frac{m_b}{\\rho_w} - C, \\end{equation} \\] <p>where \\(C\\) is a simple drainage parameter. The till is assumed to be saturated when it reaches the value \\(W_{till}^{max} = 2\\) m, therefore, the till water thickness is bounded to this value. The effective thickness of water within the till \\(N_{till}\\) is computed from the saturation ratio \\(s= W_{till} / W_{till}^{max}\\) by the formula (Bueler and Pelt, GMD, 2015):</p> \\[ \\begin{equation} N_{till} = \\min \\left\\{ P_0, N_0 \\left( \\frac{\\delta P_0}{N_0} \\right)^s 10^{(e_0/C_c)(1-s)} \\right\\}, \\end{equation} \\] <p>where \\(P_0\\) is the ice overburden pressure and the remaining parameters are constant. </p>"},{"location":"modules/processes/enthalpy/#sliding-parametrization","title":"Sliding parametrization","text":"<p>Last, the sliding coefficient \\(c\\) is defined with the Mohr-Coulomb (Cuffey and Paterson, 2010) sliding law with the effective pressure in the till:</p> \\[ \\begin{align} c  = \\tau_c u_{th}^{-m} &amp; = N_{till} \\tan(\\phi) u_{th}^{-m}, \\\\ \\end{align} \\] <p>where \\(\\phi\\) is the till friction angle.</p>"},{"location":"modules/processes/enthalpy/#ahrrenius-factor","title":"Ahrrenius factor","text":"<p>We use the Glen-Paterson-Budd-Lliboutry-Duval law, where</p> \\[A(T,\\omega)= A_c(T)(1+C \\omega) \\] <p>where \\(A_c(T)\\) is given by the Paterson-Budd law:</p> \\[  A_c(T)= A \\exp{( \u2212Q / (R \\, T_{pa}) )} \\] <p>where \\(A\\) and \\(Q\\) have different values below and above a threshold temperature. </p> \\[ A = 3.985 \\times 10^{-13} \\, s^{-1} Pa^{-3}, \\textrm{ if } T &lt;263.15 K\\] \\[ A = 1.916 \\times 10^3 \\, s^{-1} Pa^{-3}, \\textrm{else.}\\] <p>and</p> \\[ Q =  60 kJ mol^{-1},  \\textrm{ if } T &lt;263.15 K\\] \\[ Q = 139 kJ mol^{-1},  \\textrm{else.}\\] <p>These values are taken from (Paterson 1994).</p>"},{"location":"modules/processes/enthalpy/#pressure-adujsuted-temperature","title":"Pressure-adujsuted temperature","text":"<p>Melting point temperature at pressure is adjusted for pressure as follows</p> \\[ T_{pmp} = T_{0} - \\beta \\rho g d, \\] <p>where \\(d\\) is the depth, \\(T_{0}=273.15\\) is the melting temperate at standart pressure (unit [\\(K\\)]),  \\(\\beta = 7.9 \\; 10^{-8}\\) is Clausius-Clapeyron constant (unit [\\(K Pa^{-1}\\)]). Therefore, one define the \"pressure-adjusted\" temperaure \\(T_{pa}\\) as being the temperature with a shift such that its metling point temperature reference is always zero:</p> \\[ T_{pa} = T + \\beta \\rho g z. \\]"},{"location":"modules/processes/enthalpy/#numerical-scheme","title":"Numerical scheme","text":"<p>To solve the Enthalpy equation numerically, one makes use of the same horizontal and vertical discretization as used for the ice flow. Treating the horizontal advection term explicitly using an upwind scheme, the Enthalpy equation with its boundary conditions can be solved column-wise as a one-dimensional advection-diffusion equation. This is achieved implicitly for both the vertical advection and the diffusion term, which are approximated by finite differences. For each column,  one solves a small tridiagonal using the Tridiagonal Matrix Algorithm (TDMA) aka Thomas Algorithm.</p> <p>Updating the Enthalpy at time \\(t^{n+1}\\) requires to perform several sub-steps (in function ''update_enthalpy(params,state)''):</p> <ul> <li>compute the mean surface temperature \\(T^n_s\\) to enforce upper surface Dirichlet Boundary condition,</li> <li>compute the vertical discretization with respect to the ice geometry \\(h^n\\),</li> <li>compute the temperature \\(T_{pmp}\\) and enthalpy \\(E_{pmp}\\) at pressure meltinf point,</li> <li>compute the ice temperature field \\(T^n\\) from the Enthalpy \\(E^n\\),</li> <li>compute the Arrhenius factor \\(A(T^n)\\) from temperature \\(T^n\\),</li> <li>compute the 3D strain heat \\(\\phi^n\\) from ice flow field \\({\\bf u}^{n+1}\\) and rrhenius factor \\(A(T^n)\\),</li> <li>compute the 2D basal frictional heat \\(Q_{\\rm fh}^n\\), from basal velocity field \\({\\bf u}\\) and sliding coefficient \\(c^n\\),</li> <li>compute the \\(UPWIND^n\\) term for the explicit treatement of the horizontal advection,</li> <li>compute the surface Enthalpy \\(E^n_s\\) from the surface temperature \\(T^n_s\\),</li> <li>compute the new enthalpy \\(E^{n+1}\\) field solving one-dimension column-wise advection-diffusion equation, as well as the basal melt rate, this is the main updating step,</li> <li>compute the water thickness in the till \\(W^{n+1}\\),</li> <li>compute the sliding parametrization \\(c^{n+1}\\). </li> </ul>"},{"location":"modules/processes/enthalpy/#numerical-stability-time-stepping","title":"Numerical stability -- time stepping","text":"<p>Here one updates the enthalpy as many times as the ice flow, we assume that the time step for the explicit advection is more restrictive than the implicit diffusion-advection problem.</p>"},{"location":"modules/processes/enthalpy/#dependencies","title":"Dependencies","text":"<ul> <li>the enthalpy module builds upon the module iceflow</li> <li>one needs to have the vertical_iceflow module activated to provide the vertical velocitiy</li> <li>make sure to have params.dim_arrhenius = 3</li> <li>make sure to have params.new_friction_param = true</li> <li>make sure to ave enough retraining retrain_iceflow_emulator_freq: 1, possibly retrain_iceflow_emulator_nbit more than 1.</li> </ul>"},{"location":"modules/processes/gflex/","title":"gflex","text":"<p>This IGM module permits to model the isostasy or upward motion of the  lithosphere when loaded with thick ice, it uses the  gflex python module writen by Andy Wickert.</p> <p>This function was implemented in IGM by J\u00fcrgen Mey.</p> <p>Parameters are the update frequency <code>gflex_update_freq</code> and the Elastic thickness [m] (Te) <code>gflex_default_Te</code>.</p> <p>This module only runs on CPU, which may be an issue for treating very large arrays. On the other hand, we do not expect a frequent update, therefore, this module should not be overall too consuming.</p>"},{"location":"modules/processes/gflex/#config-structure","title":"Config Structure","text":"<pre><code>gflex:\n  update_freq: 100.0 # help=\"Update gflex each X years (1)\"\n  default_Te: 50000 # help=\"Default value for Te (Elastic thickness [m]) if not given as ncdf file\"\n  dx: 1000 # help=\"Default resolution for computing isostasy (m).\"\n  pad: False # help=\"Default padding option\"\n  quiet: True # help=\"Default padding option\"\n</code></pre>"},{"location":"modules/processes/gflex/#arguments","title":"Arguments","text":"Name Type Units Description Default Value update_freq float years Update gflex each X years 100.0 default_Te float meters Default value for Te (Elastic thickness) if not given as ncdf file 50000 dx float meters Default resolution for computing isostasy 1000 pad boolean None Default padding option False quiet boolean None Default padding option True"},{"location":"modules/processes/gflex/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/glerosion/","title":"glerosion","text":"<p>This IGM module implements change in basal topography (due to glacial erosion). The bedrock is updated (with a frequency provided by parameter <code>glerosion_update_freq years</code>) assuming a power erosion law, i.e. the erosion rate is proportional (parameter <code>glerosion_cst</code>) to a power (parameter <code>glerosion_exp</code>) of the sliding velocity magnitude. </p> <p>By default, we use the parameters from</p> <pre><code> Herman, F. et al., Erosion by an Alpine glacier. Science 350, 193-195, 2015.\n</code></pre>"},{"location":"modules/processes/glerosion/#config-structure","title":"Config Structure","text":"<pre><code>glerosion:\n  cst: 2.7e-7 # help=\"Erosion multiplicative factor, here taken from Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193\u2013195 (2015)\",\n  exp: 2 # help=\"Erosion exponent factor, here taken from Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193\u2013195 (2015)\",\n  update_freq: 1 # help=\"Update the erosion only each X years (Default: 1)\"\n</code></pre>"},{"location":"modules/processes/glerosion/#arguments","title":"Arguments","text":"Name Type Units Description Default Value cst float dimensionless Erosion multiplicative factor, here taken from Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193\u2013195 (2015) 2.7e-07 exp float dimensionless Erosion exponent factor, here taken from Herman, F. et al. Eerosion by an Alpine glacier. Science 350, 193\u2013195 (2015) 2 update_freq float years Update the erosion only each X years 1"},{"location":"modules/processes/glerosion/#example-usage","title":"Example Usage","text":"<p>Hi</p>"},{"location":"modules/processes/iceflow/","title":"Iceflow","text":"<p>This IGM module models ice flow dynamics in 3D using a Convolutional Neural Network based on Physics Informed Neural Network as described in this paper. In more details, we train a CNN to minimise the energy associated with high-order ice flow equations within the time iterations of a glacier evolution model. As a result, our iflo_emulator is a computationally-efficient alternative to traditional solvers, it is capable to handle a variety of ice flow regimes and memorize previous solutions.</p> <p>Pre-trained emulators are provided by defaults (parameter <code>iflo_emulator</code>). However, a from scratch iflo_emulator can be requested with <code>iflo_emulator=\"\"</code>. The most important parameters are:</p> <ul> <li>physical parameters </li> </ul> <pre><code>\"iflo_init_slidingco\": 10000.0  # Init slid. coeff. ($Mpa^{-3} y^{-1} m$)\n\"iflo_init_arrhenius\": 78.0     # Init Arrhenius cts ($Mpa^{-3} y^{-1}$)\n\"iflo_exp_glen\": 3              # Glen's exponent\n\"iflo_exp_weertman\":  3         # Weertman's sliding law exponent\n</code></pre> <ul> <li>related to the vertical discretization:</li> </ul> <pre><code>\"iflo_Nz\": 10                 # number of vertical layers\n\"iflo_vert_spacing\": 4.0     # 1.0 for equal vertical spacing, 4.0 otherwise\n</code></pre> <ul> <li>learning rate and frequency of retraining:</li> </ul> <pre><code>\"iflo_retrain_emulator_lr\": 0.00002 \n\"iflo_retrain_emulator_freq\": 5     \n</code></pre> <p>While this module was targeted for deep learning emulation, it important parameters for solving are :</p> <p>is possible to use the solver (<code>iflo_type='solved'</code>) instead of the default iflo_emulator (<code>iflo_type='emulated'</code>), or use the two together (<code>iflo_type='diagnostic'</code>) to assess the emaultor against the solver. Most important parameters for solving are :</p> <pre><code>\"iflo_solve_step_size\": 0.00002 \n\"iflo_solve_nbitmax\": 5     \n</code></pre> <p>One may choose between 2D arrhenius factor by changing parameters between <code>iflo_dim_arrhenius=2</code> or <code>iflo_dim_arrhenius=3</code> -- le later is necessary for the enthalpy model.</p> <p>When treating ery large arrays, retraining must be done sequentially patch-wise for memory reason. The size of the pathc is controlled by parameter <code>iflo_multiple_window_size=750</code>.</p>"},{"location":"modules/processes/iceflow/#config-structure","title":"Config Structure","text":"<pre><code>iceflow:\n  iceflow: # temporarly mirroring the code but would recommend just cateogorizing the prameters that make sense (i.e. network params, retrain, paths, etc.)\n    run_pretraining: False\n    run_data_assimilation: False # help=\"Run the data assimilation scheme\"\n    type: \"emulated\" # help=\"Type of iceflow: it can emulated (default), solved, or in diagnostic mode to investigate the fidelity of the emulator towads the solver\"\n    pretrained_emulator: True # help=\"Do we take a pretrained emulator or start from scratch?\"\n    emulator: \"\" # help=\"Directory path of the deep-learning pretrained ice flow model, take from the library if empty string\"\n    init_slidingco: 0.0464 # help=\"Initial sliding coefficient slidingco\"\n    init_arrhenius: 78.0 # help=\"Initial arrhenius factor arrhenuis\"\n    enhancement_factor: 1.0 # help=\"Enhancement factor multiying the arrhenius factor\"\n    regu_glen: 1.0e-5 # help=\"Regularization parameter for Glen's flow law\"\n    regu_weertman: 1.0e-10 # help=\"Regularization parameter for Weertman's sliding law\"\n    exp_glen: 3.0 # help=\"Glen's flow law exponent\"\n    exp_weertman: 3.0 # help=\"Weertman's law exponent\n    gravity_cst: 9.81 # help=\"Gravitational constant\"\n    ice_density: 910.0 # help=\"Density of ice\"\n    new_friction_param: True # help=\"Sliding coeeficient (this describe slidingco differently with slidingco**-(1.0 / exp_weertman) instead of slidingco as before)\"\n    save_model: False # help=\"save the iceflow emaultor at the end of the simulation\"\n    Nz: 10 # help=\"Number of grid point for the vertical discretization\"\n    vert_spacing: 4.0 # help=\"Parameter controlling the discrtuzation density to get more point near the bed than near the the surface. 1.0 means equal vertical spacing.\"\n    thr_ice_thk: 0.1 # help=\"Threshold Ice thickness for computing strain rate\"\n    solve_step_size: 1.0 # help=\"Step size for the optimizer using when solving Blatter-Pattyn in solver mode\"\n    solve_nbitmax: 100 # help=\"Maximum number of iteration for the optimizer using when solving Blatter-Pattyn in solver mode\"\n    solve_stop_if_no_decrease: True # help=\"This permits to stop the solver if the energy does not decrease\"\n    fieldin: [\"thk\", \"usurf\", \"arrhenius\", \"slidingco\", \"dX\"] # help=\"Input fields of the iceflow emulator\"\n    dim_arrhenius: 2 # help=\"Dimension of the arrhenius factor (horizontal 2D or 3D)\"\n    retrain_emulator_freq: 10 # help=\"Frequency at which the emulator is retrained, 0 means never, 1 means at each time step, 2 means every two time steps, etc.\"\n    retrain_emulator_lr: 0.00002 # help=\"Learning rate for the retraining of the emulator\"\n    retrain_emulator_lr_init: 0.0001\n    retrain_warm_up_it: -1.0e+10\n    retrain_emulator_nbit_init: 1 # help=\"Number of iterations done at the first time step for the retraining of the emulator\"\n    retrain_emulator_nbit: 1 # help=\"Number of iterations done at each time step for the retraining of the emulator\"\n    retrain_emulator_framesizemax: 750 # help=\"Size of the patch used for retraining the emulator, this is usefull for large size arrays, otherwise the GPU memory can be overloaded\"\n    multiple_window_size: 0 # help=\"If a U-net, this force window size a multiple of 2**N\"\n    force_max_velbar: 0.0 # help=\"This permits to artifically upper-bound velocities, active if &gt; 0\"\n    network: \"cnn\" # help=\"This is the type of network, it can be cnn or unet\"\n    activation: \"LeakyReLU\" # help=\"Activation function, it can be lrelu, relu, tanh, sigmoid, etc.\"\n    nb_layers: 16 # help=\"Number of layers in the CNN\"\n    nb_blocks: 4 # help=\"Number of block layer in the U-net\"\n    nb_out_filter: 32 # help=\"Number of output filters in the CNN\"\n    conv_ker_size: 3 # help=\"Size of the convolution kernel\"\n    dropout_rate: 0 # help=\"Dropout rate in the CNN\"\n    weight_initialization: \"glorot_uniform\" # help=\"glorot_uniform, he_normal, lecun_normal\"\n    exclude_borders: 0 # help=\"This is a quick fix of the border issue, other the physics informed emaulator shows zero velocity at the border\"\n    cf_eswn: [] # help=\"This forces calving front at the border of the domain in the side given in the list\"\n    cf_cond: False # help=\"This forces calving front at the border of the domain in the side given in the list\"\n    regu: 0.0 # help=\"This regularizes the energy forcing ice flow to be smooth in the horizontal direction\"\n    min_sr: 1.0e-20 # help=\"Minimum strain rate\"\n    max_sr: 1.0e+20 # help=\"Maximum strain rate\"\n    force_negative_gravitational_energy: False # help=\"Force energy gravitational term to be negative\"\n    optimizer_solver: 'Adam' # help=\"Tpe of Optimizer for the solver\"\n    optimizer_lbfgs: False # help=\"optimizer_lbfgs\"\n    optimizer_emulator: 'Adam' # help=\"Tpe of Optimizer for the emulator\"\n    optimizer_emulator_clipnorm: 1.0e+10\n    optimizer_emulator_epsilon: 1.0e-07\n    save_cost_emulator: \"\" # \n    save_cost_solver: \"\"\n    output_directory: \"\"\n  optimize:\n    vars_to_save: # help=\"List of variables to be recorded in the ncdef file\"\n        - \"usurf\"\n        - \"thk\"\n        - \"slidingco\"\n        - \"velsurf_mag\"\n        - \"velsurfobs_mag\"\n        - \"divflux\"\n        - \"icemask\"\n    init_zero_thk: False # help=\"Initialize the optimization with zero ice thickness\"\n    regu_param_thk: 10.0 # help=\"Regularization weight for the ice thickness in the optimization\"\n    regu_param_slidingco: 1.0 # help=\"Regularization weight for the slidingco field in the optimization\"\n    regu_param_arrhenius: 10.0 # help=\"Regularization weight for the arrhenius field in the optimization\"\n    regu_param_div: 1.0 # help=\"Regularization weight for the divrgence field in the optimization\"\n    smooth_anisotropy_factor: 0.2 # help=\"Smooth anisotropy factor for the ice thickness regularization in the optimization\"\n    smooth_anisotropy_factor_sl: 1.0 # help=\"Smooth anisotropy factor for the slidingco regularization in the optimization\"\n    convexity_weight: 0.002 # help=\"Convexity weight for the ice thickness regularization in the optimization\"\n    convexity_power: 1.3 # help=\"Power b in the area-volume scaling V ~ a * A^b taking fom 'An estimate of global glacier volume', A. Grinste, TC, 2013\"\n    usurfobs_std: 2.0 # help=\"Confidence/STD of the top ice surface as input data for the optimization\"\n    velsurfobs_std: 1.0 # help=\"Confidence/STD of the surface ice velocities as input data for the optimization (if 0, velsurfobs_std field must be given)\"\n    thkobs_std: 3.0 # help=\"Confidence/STD of the ice thickness profiles (unless given)\"\n    divfluxobs_std: 1.0 # help=\"Confidence/STD of the flux divergence as input data for the optimization (if 0, divfluxobs_std field must be given)\"\n    divflux_method: \"upwind\" # help=\"Compute the divergence of the flux using the upwind or centered method\"\n    force_zero_sum_divflux: False # help=\"Add a penalty to the cost function to force the sum of the divergence of the flux to be zero\"\n    scaling_thk: 2.0 # help=\"Scaling factor for the ice thickness in the optimization, serve to adjust step-size of each controls relative to each other\"\n    scaling_usurf: 0.5 # help=\"Scaling factor for the ice thickness in the optimization, serve to adjust step-size of each controls relative to each other\"\n    scaling_slidingco: 0.0001 # help=\"Scaling factor for the slidingco in the optimization, serve to adjust step-size of each controls relative to each other\"\n    scaling_arrhenius: 0.1 # help=\"Scaling factor for the Arrhenius in the optimization, serve to adjust step-size of each controls relative to each other\"\n    control: [\"thk\"] # help=\"List of optimized variables for the optimization\"\n    cost: [\"velsurf\", \"thk\", \"icemask\"] # help=\"List of cost components for the optimization\"\n    nbitmin: 50 # help=\"Min iterations for the optimization\"\n    nbitmax: 500 # help=\"Max iterations for the optimization\"\n    step_size: 1.0 # help=\"Step size for the optimization\"\n    step_size_decay: 0.9 # help=\"Decay step size parameter for the optimization\"\n    output_freq: 50 # help=\"Frequency of the output for the optimization\"\n    save_result_in_ncdf: \"geology-optimized.nc\" # help=\"Geology input file\"\n    plot2d_live: True # help=\"plot2d_live_inversion\"\n    plot2d: True # help=\"plot 2d inversion\"\n    save_iterat_in_ncdf: True # help=\"write_ncdf_optimize\"\n    editor_plot2d: \"vs\" # help=\"optimized for VS code (vs) or spyder (sp) for live plot\"\n    uniformize_thkobs: True # help=\"uniformize the density of thkobs\"\n    sole_mask: False # help=\"sole_mask\"\n    retrain_iceflow_model: True # help=\"Retrain the iceflow model simulatounously ?\"\n    to_regularize: 'topg' # help=\"Field to regularize : topg or thk\"\n    include_low_speed_term: False # help=\"include_low_speed_term\"\n    infer_params: False # help=\"infer slidingco and convexity weight from velocity observations\"\n    tidewater_glacier: False # help=\"Is the glacier you're trying to infer parameters for a tidewater type?\"\n    vol_std: 1000.0 # help=\"Confidence/STD of the volume estimates from volume-area scaling\"\n    fix_opti_normalization_issue: False # help=\"formerly, the oce was mixing reduce_mean and l2_loss leadinf to dependence to the resolution of the grid\"\n    velsurfobs_thr: 0.0 # \"help=\"Threshold for the surface ice velocities as input data for the optimization, anything below this value will be ignored\"\n    log_slidingco: False\n  pretraining:\n    data_dir: \"surflib3d_shape_100\" # help=\"Directory of the data of the glacier catalogu\"\n    batch_size: 1 # help=\"Batch size\"\n    freq_test: 20 # help=\"Frequence of the test\"\n    train_iceflow_emulator_restart_lr: 2500 # help=\"Restart frequency for the learning rate\"\n    epochs: 5000 # help=\"Number of epochs\"\n    min_arrhenius: 5.0 # help=\"Minium Arrhenius factor\"\n    max_arrhenius: 151.0 # help=\"Maximum Arrhenius factor\"\n    min_slidingco: 0.0 # help=\"Minimum sliding coefficient\"\n    max_slidingco: 20000.0 # help=\"Maximum sliding coefficient\"\n    min_coarsen: 0 # help=\"Minimum coarsening factor\"\n    max_coarsen: 2 # help=\"Maximum coarsening factor\"\n    soft_begining: 500 # help=\"soft_begining, if 0 explore all parameters btwe min and max, otherwise, only explore from this iteration while keeping mid-value fir the first it.\" \n</code></pre>"},{"location":"modules/processes/iceflow/#arguments","title":"Arguments","text":"Name Type Units Description Default Value Iceflow run_pretraining boolean boolean False run_data_assimilation boolean boolean Run the data assimilation scheme False type string string Type of iceflow: it can be emulated (default), solved, or in diagnostic mode to investigate the fidelity of the emulator towards the solver emulated pretrained_emulator boolean boolean Do we take a pretrained emulator or start from scratch? True emulator file path file path Directory path of the deep-learning pretrained ice flow model, take from the library if empty string init_slidingco float float Initial sliding coefficient slidingco 0.0464 init_arrhenius float float Initial arrhenius factor arrhenius 78.0 enhancement_factor float float Enhancement factor multiplying the arrhenius factor 1.0 regu_glen float float Regularization parameter for Glen's flow law 1e-05 regu_weertman float float Regularization parameter for Weertman's sliding law 1e-10 exp_glen integer integer Glen's flow law exponent 3.0 exp_weertman integer integer Weertman's law exponent 3.0 gravity_cst float float Gravitational constant 9.81 ice_density float float Density of ice 910.0 new_friction_param boolean boolean Sliding coefficient (this describes slidingco differently with slidingco**-(1.0 / exp_weertman) instead of slidingco as before) True save_model boolean boolean Save the iceflow emulator at the end of the simulation False Nz integer integer Number of grid points for the vertical discretization 10 vert_spacing float float Parameter controlling the discretization density to get more points near the bed than near the surface. 1.0 means equal vertical spacing. 4.0 thr_ice_thk float float Threshold Ice thickness for computing strain rate 0.1 solve_step_size float float Step size for the optimizer used when solving Blatter-Pattyn in solver mode 1.0 solve_nbitmax integer integer Maximum number of iterations for the optimizer used when solving Blatter-Pattyn in solver mode 100 solve_stop_if_no_decrease boolean boolean This permits to stop the solver if the energy does not decrease True fieldin list list Input fields of the iceflow emulator ['thk', 'usurf', 'arrhenius', 'slidingco', 'dX'] dim_arrhenius integer integer Dimension of the arrhenius factor (horizontal 2D or 3D) 2 retrain_emulator_freq integer integer Frequency at which the emulator is retrained, 0 means never, 1 means at each time step, 2 means every two time steps, etc. 10 retrain_emulator_lr float float Learning rate for the retraining of the emulator 2e-05 retrain_emulator_lr_init None None Initial Learning rate for the retraining of the emulator 0.0001 retrain_warm_up_it year year Warm-up nb of iteration allowing intense initial training -10000000000.0 retrain_emulator_nbit_init integer integer Number of iterations done at the first time step for the retraining of the emulator 1 retrain_emulator_nbit integer integer Number of iterations done at each time step for the retraining of the emulator 1 retrain_emulator_framesizemax integer integer Size of the patch used for retraining the emulator, this is useful for large size arrays, otherwise the GPU memory can be overloaded 750 multiple_window_size integer integer If a U-net, this forces window size to be a multiple of 2**N 0 force_max_velbar float float This permits to artificially upper-bound velocities, active if &gt; 0 0.0 network string string This is the type of network, it can be cnn or unet cnn activation string string Activation function, it can be lrelu, relu, tanh, sigmoid, etc. LeakyReLU nb_layers integer integer Number of layers in the CNN 16 nb_blocks integer integer Number of block layers in the U-net 4 nb_out_filter integer integer Number of output filters in the CNN 32 conv_ker_size integer integer Size of the convolution kernel 3 dropout_rate float float Dropout rate in the CNN 0 weight_initialization string string glorot_uniform, he_normal, lecun_normal glorot_uniform exclude_borders integer integer This is a quick fix of the border issue, otherwise the physics-informed emulator shows zero velocity at the border 0 cf_eswn list list This forces calving front at the border of the domain in the side given in the list [] cf_cond boolean boolean This forces calving front at the border of the domain in the side given in the list False regu float float This regularizes the energy forcing ice flow to be smooth in the horizontal direction 0.0 min_sr float float Minimum strain rate 1e-20 max_sr float float Maximum strain rate 1e+20 force_negative_gravitational_energy boolean boolean Force energy gravitational term to be negative False optimizer_solver string string Type of Optimizer for the solver Adam optimizer_lbfgs boolean boolean iflo_optimizer_lbfgs False optimizer_emulator string string Type of Optimizer for the emulator Adam optimizer_emulator_clipnorm float float If set, the gradient of each weight is individually clipped so that its norm is no higher than this value. 10000000000.0 optimizer_emulator_epsilon float float A small constant for numerical stability for the Adam optimizer 1e-07 save_cost_emulator string string save_cost_solver string string output_directory file path file path Optimize vars_to_save list list List of variables to be recorded in the ncdf file ['usurf', 'thk', 'slidingco', 'velsurf_mag', 'velsurfobs_mag', 'divflux', 'icemask'] init_zero_thk boolean boolean Initialize the optimization with zero ice thickness False regu_param_thk float float Regularization weight for the ice thickness in the optimization 10.0 regu_param_slidingco float float Regularization weight for the slidingco field in the optimization 1.0 regu_param_arrhenius float float Regularization weight for the arrhenius field in the optimization 10.0 regu_param_div float float Regularization weight for the divergence field in the optimization 1.0 smooth_anisotropy_factor float float Smooth anisotropy factor for the ice thickness regularization in the optimization 0.2 smooth_anisotropy_factor_sl float float Smooth anisotropy factor for the slidingco regularization in the optimization 1.0 convexity_weight float float Convexity weight for the ice thickness regularization in the optimization 0.002 convexity_power float float Power b in the area-volume scaling V ~ a * A^b taken from 'An estimate of global glacier volume', A. Grinsted, TC, 2013 1.3 usurfobs_std float float Confidence/STD of the top ice surface as input data for the optimization 2.0 velsurfobs_std float float Confidence/STD of the surface ice velocities as input data for the optimization (if 0, velsurfobs_std field must be given) 1.0 thkobs_std float float Confidence/STD of the ice thickness profiles (unless given) 3.0 divfluxobs_std float float Confidence/STD of the flux divergence as input data for the optimization (if 0, divfluxobs_std field must be given) 1.0 divflux_method string string Compute the divergence of the flux using the upwind or centered method upwind force_zero_sum_divflux boolean boolean Add a penalty to the cost function to force the sum of the divergence of the flux to be zero False scaling_thk float float Scaling factor for the ice thickness in the optimization, serves to adjust step-size of each control relative to each other 2.0 scaling_usurf float float Scaling factor for the ice thickness in the optimization, serves to adjust step-size of each control relative to each other 0.5 scaling_slidingco float float Scaling factor for the slidingco in the optimization, serves to adjust step-size of each control relative to each other 0.0001 scaling_arrhenius float float Scaling factor for the Arrhenius in the optimization, serves to adjust step-size of each control relative to each other 0.1 control list list List of optimized variables for the optimization ['thk'] cost list list List of cost components for the optimization ['velsurf', 'thk', 'icemask'] nbitmin integer integer Min iterations for the optimization 50 nbitmax integer integer Max iterations for the optimization 500 step_size float float Step size for the optimization 1.0 step_size_decay float float Decay step size parameter for the optimization 0.9 output_freq integer integer Frequency of the output for the optimization 50 save_result_in_ncdf file path file path Geology input file geology-optimized.nc plot2d_live boolean boolean plot2d_live_inversion True plot2d boolean boolean plot 2d inversion True save_iterat_in_ncdf boolean boolean write_ncdf_optimize True editor_plot2d string string optimized for VS code (vs) or spyder (sp) for live plot vs uniformize_thkobs boolean boolean uniformize the density of thkobs True sole_mask boolean boolean sole_mask False retrain_iceflow_model boolean boolean Retrain the iceflow model simultaneously? True to_regularize string string Field to regularize: topg or thk topg include_low_speed_term boolean boolean opti_include_low_speed_term False infer_params boolean boolean Infer slidingco and convexity weight from velocity observations False tidewater_glacier boolean boolean Is the glacier you're trying to infer parameters for a tidewater type? False vol_std float float Confidence/STD of the volume estimates from volume-area scaling 1000.0 fix_opti_normalization_issue boolean boolean Formerly, the oce was mixing reduce_mean and l2_loss leading to dependence to the resolution of the grid False velsurfobs_thr float meters per year? Threshold for the surface ice velocities as input data for the optimization, anything below this value will be ignored 0.0 log_slidingco boolean boolean Optimize the log of the sliding coefficient instead of the slidingco itself False Pretraining data_dir str dimensionaless Directory of the data of the glacier catalog surflib3d_shape_100 batch_size int dimensionaless Batch size 1 freq_test int dimensionaless Frequency of the test 20 train_iceflow_emulator_restart_lr int dimensionaless Restart frequency for the learning rate 2500 epochs int dimensionaless Number of epochs 5000 min_arrhenius float dimensionaless Minimum Arrhenius factor 5.0 max_arrhenius float dimensionaless Maximum Arrhenius factor 151.0 min_slidingco float dimensionaless Minimum sliding coefficient 0.0 max_slidingco float dimensionaless Maximum sliding coefficient 20000.0 min_coarsen int dimensionaless Minimum coarsening factor 0 max_coarsen int dimensionaless Maximum coarsening factor 2 soft_begining int dimensionaless soft_begining, if 0 explore all parameters between min and max, otherwise, only explore from this iteration while keeping mid-value for the first it. 500"},{"location":"modules/processes/iceflow/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/particles/","title":"particles","text":"<p>This IGM module implements a particle tracking routine, which computes trajectory of virtual particles advected by the ice flow. The specificity is that it runs in live time during the forward mdodel run and a large number of particles can be computed tanks to the parrallel implementation with TensorFlow. The routine includes particle seeding (by default in the accumulation area at regular intervals, but this can be customized), and tracking (advection by the velocity field in 3D). There is currently no strategy for removing particles, therefore, there is risk of overloading the memory when using this routine as it is for long time and/or with intense seeding.</p> <p>There are currently 2 implementations (switch with parameter <code>part_tracking_method</code>:</p> <ul> <li> <p><code>'simple'</code>: Horizontal and vertical directions are treated differently: i) In the horizontal plan, particles are advected with the horizontal velocity field (interpolated bi-linearly) ii) In the vertical direction, particles are tracked along the ice column scaled between 0 and 1 (0 at the bed, 1 at the top surface) with the  relative position along the ice column. Particles are always initialized at 1 relative height (assumed to be on the surface). The evolution of the particle within the ice column through time is computed according to the surface mass balance: the particle deepens when the surface mass balance is positive (the relative height decreases), and re-emerge when the surface mass balance is negative (the relative height increases).</p> </li> <li> <p><code>'3d'</code>: requires to activate module <code>vert_flow</code>, which computes the vertical velocity by integrating the divergence of the horizontal velocity. This permits in turn to perform 3D particle tracking.</p> </li> </ul> <p>For now, <code>part_tracking_method</code> is by default set to  <code>'simple'</code>, as the  <code>'3d'</code> method (and the dependence <code>vert_flow</code>) needs to further tested.</p> <p>Note that you my adapt the seeding to your need. You may keep the default seeding in the accumulation area setting the seeding frequency with <code>part_frequency_seeding</code> parameter and the seeding density <code>part_density_seeding</code> parameter. Alternatively, you may define your own seeding strategy (e.g. seeding close to rock walls/nunataks). To do so, you may redefine the function <code>seeding_particles()</code> in a file <code>particles.py</code> provided in the working directory (check the example aletsch-1880-2100). When excuted, <code>igm_run</code> will overide the original function <code>seeding_particles()</code> with the new user-defined one.</p> <p>The module needs horizontal velocities (state.U), as well as vertical speeds (state.W) that ice computed with the vert_flow module when <code>part_tracking_method</code> is set to <code>3d</code>. </p> <p>Note: in the code, positions of particles are recorded within a vector of lenght te number of traked particels state.xpos, state.ypos, state.zpos. Variable state.rhpos provide the relative height within the ice column (1 at the surface, 0 at the bed). At each time step, the weight of surface debris contains in each cell the 2D  horizontal grid is computed, and stored in variable state.weight_particles.</p>"},{"location":"modules/processes/particles/#config-structure","title":"Config Structure","text":"<pre><code>particles:\n  tracking_method: 3d # help=\"Method for tracking particles (3d or simple)\"\n  frequency_seeding: 50 # help=\"Frequency of seeding (unit : year)\"\n  density_seeding: 0.2 # help=\"Density of seeding (1 means we seed all pixels, 0.2 means we seed each 5 grid cell, ect.)\"\n  tlast_seeding_init: -1.0e+5000 # help=\"Initialize the date of last seeding. If default value, the seeding will start the first year of the simulation. Changing this value alouds to differ it\n</code></pre>"},{"location":"modules/processes/particles/#arguments","title":"Arguments","text":"Name Type Units Description Default Value tracking_method str string Method for tracking particles (3d or simple) 3d frequency_seeding float years Frequency of seeding 50 density_seeding float dimensionless Density of seeding (1 means we seed all pixels, 0.2 means we seed each 5 grid cell, etc.) 0.2 tlast_seeding_init float years Initialize the date of last seeding. If default value, the seeding will start the first year of the simulation. Changing this value allows to defer it -inf"},{"location":"modules/processes/particles/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/read_output/","title":"read_output","text":"<p>This IGM module permits to read an output NetCDF file produced previously and to run igm as if these quantities  were shortly computed, this is mainly usefull for testing postprocessing module independently.</p>"},{"location":"modules/processes/read_output/#config-structure","title":"Config Structure","text":"<pre><code>read_output:\n  input_file: output.nc # help=\"NetCDF input data file\"\n  crop: False # help=\"Crop the data from NetCDF file with given top/down/left/right bounds\"\n  xmin: -1.0e+20 # help=\"X left coordinate for cropping the NetCDF data\"\n  xmax: 1.0e+20 # help=\"X right coordinate for cropping the NetCDF data\"\n  ymin: -1.0e+20 # help=\"Y bottom coordinate fro cropping the NetCDF data\"\n  ymax: 1.0e+20 # help=\"Y top coordinate for cropping the NetCDF data\"\n</code></pre>"},{"location":"modules/processes/read_output/#arguments","title":"Arguments","text":"Name Type Units Description Default Value input_file str file path NetCDF input data file output.nc crop bool boolean Crop the data from NetCDF file with given top/down/left/right bounds False xmin float float X left coordinate for cropping the NetCDF data -1e+20 xmax float float X right coordinate for cropping the NetCDF data 1e+20 ymin float float Y bottom coordinate for cropping the NetCDF data -1e+20 ymax float float Y top coordinate for cropping the NetCDF data 1e+20"},{"location":"modules/processes/read_output/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/rockflow/","title":"rockflow","text":"<p>This module extends the ice flow outside the glaciated area, by giving a constant speed and along-slope flow direction. This modules serves to track rock-like particles (with module <code>particles</code>) everywhere in ice-free and ice-filled areas, particles being either advected at constant steep (controlled by parameter <code>rock_flow_speed</code>) following the stepest gradient of the ice-free terrain in 2D, or by ice flow in 3D.</p>"},{"location":"modules/processes/rockflow/#config-structure","title":"Config Structure","text":"<pre><code>rockflow:\n  flow_speed: 1.0 # help=\"Speed of rock flow along the slope in m/y\"\n</code></pre>"},{"location":"modules/processes/rockflow/#arguments","title":"Arguments","text":"Name Type Units Description Default Value flow_speed float meters per year Speed of rock flow along the slope 1.0"},{"location":"modules/processes/rockflow/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/smb_accpdd/","title":"smb_accpdd","text":"<p>This modules allows you to calculate ...</p>"},{"location":"modules/processes/smb_accpdd/#config-structure","title":"Config Structure","text":"<pre><code>smb_accpdd:\n  update_freq: 1 # help=\"Update the mass balance each X years\"\n  refreeze_factor: 0.6 # help=\"Refreezing factor\"\n  thr_temp_snow: 0.0 # help=\"Threshold temperature for solid precipitation\"\n  thr_temp_rain: 2.0 # help=\"Threshold temperature for liquid precipitation\"\n  melt_factor_snow: 1.095726596343 # help=\"Degree-day factor for snow (ice eq.) (unit: meter / (Kelvin year))\"\n  melt_factor_ice:  2.921937590248 # help=\"Degree-day factor for ice (ice eq.) (unit: meter / (Kelvin year))\"\n  shift_hydro_year: 0.75 # help=\"This serves to start Oct 1. the acc/melt computation\"\n  ice_density: 910.0 # help=\"Density of ice for conversion of SMB into ice equivalent\"\n  wat_density: 1000.0 # help=\"Density of water\"\n</code></pre>"},{"location":"modules/processes/smb_accpdd/#arguments","title":"Arguments","text":"Name Type Units Description Default Value update_freq float years Update the mass balance each X years 1 refreeze_factor float dimensionless Refreezing factor 0.6 thr_temp_snow float degrees Celsius Threshold temperature for solid precipitation 0.0 thr_temp_rain float degrees Celsius Threshold temperature for liquid precipitation 2.0 melt_factor_snow float meters per Kelvin per year Degree-day factor for snow (ice eq.) 1.095726596343 melt_factor_ice float meters per Kelvin per year Degree-day factor for ice (ice eq.) 2.921937590248 shift_hydro_year float dimensionless This serves to start Oct 1. the acc/melt computation 0.75 ice_density float kilograms per cubic meter Density of ice for conversion of SMB into ice equivalent 910.0 wat_density float kilograms per cubic meter Density of water 1000.0"},{"location":"modules/processes/smb_accpdd/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/smb_oggm/","title":"smb_oggm","text":"<p>Module <code>smb_oggm</code> implements the monthly temperature index model calibrated on geodetic MB data (Hugonnet, 2021) by OGGM. The yearly surface mass balance  is computed with </p> \\[ SMB = \\frac{\\rho_w}{\\rho_i}  \\sum_{i=1}^{12} \\left( P_i^{sol} - d_f \\max \\{ T_i - T_{melt}, 0 \\} \\right), \\] <p>where \\(P_i^{sol}\\) is the is the monthly solid precipitation, \\(T_i\\) is the monthly temperature and \\(T_{melt}\\) is the air temperature above which ice melt is assumed to occur (parameter <code>temp_melt</code>), \\(d_f\\) is the melt factor (parameter <code>melt_f</code>), and $\\frac{\\rho_w}{\\rho_i} $ is the ratio of water to ice density. Solid precipitation \\(P_i^{sol}\\) is computed out of precipitation and temperature such that it equals precipitation when the temperature is lower than a certain threshold (parameter <code>temp_all_solid</code>), zero above another threshold (parameter <code>temp_all_liq</code>), with a linear transition between the two. Module <code>oggm_shop</code> provides all calibrated parameters.</p>"},{"location":"modules/processes/smb_oggm/#config-structure","title":"Config Structure","text":"<pre><code>smb_oggm:\n  update_freq: 1 # help=\"Update the mass balance each X years\"\n  ice_density: 910.0 # help=\"Density of ice for conversion of SMB into ice equivalent\"\n  wat_density: 1000.0 # help=\"Density of water\"\n  melt_enhancer: 1 # help=\"Melt enhancer factor\"\n</code></pre>"},{"location":"modules/processes/smb_oggm/#arguments","title":"Arguments","text":"Name Type Units Description Default Value update_freq float years Update the mass balance each X years 1 ice_density float kilograms per cubic meter Density of ice for conversion of SMB into ice equivalent 910.0 wat_density float kilograms per cubic meter Density of water 1000.0 melt_enhancer float dimensionless Melt enhancer factor 1"},{"location":"modules/processes/smb_oggm/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/smb_simple/","title":"smb_simple","text":"<p>This IGM modules models a simple surface mass balance model parametrized by time-evolving ELA \\(z_{ELA}\\), ablation \\(\\beta_{abl}\\) and accumulation \\(\\beta_{acc}\\) gradients, and max accumulation \\(m_{acc}\\) parameters:</p> \\[SMB(z)=min(\\beta_{acc} (z-z_{ELA}),m_{acc})\\quad\\textrm{if}\\;z&gt;z_{ELA},$$ $$SMB(z)=\\beta_{abl} (z-z_{ELA})\\quad\\textrm{else}.\\] <p>These parameters may be given in file (file name given in <code>smb_simple_file</code> parameter), which look like this</p> <pre><code>time   gradabl  gradacc    ela   accmax\n1900     0.009    0.005   2800      2.0\n2000     0.009    0.005   2900      2.0\n2100     0.009    0.005   3300      2.0\n</code></pre> <p>or directly as parameter in the cconfig <code>params.json</code> file:</p> <pre><code>\"smb_simple_array\": [ \n                     [\"time\", \"gradabl\", \"gradacc\", \"ela\", \"accmax\"],\n                     [ 1900,      0.009,     0.005,  2800,      2.0],\n                     [ 2000,      0.009,     0.005,  2900,      2.0],\n                     [ 2100,      0.009,     0.005,  3300,      2.0]\n                    ],\n</code></pre> <p>If parameter <code>smb_simple_array</code> is set to empty list <code>[]</code>, then it will read the file <code>smb_simple_file</code>, otherwise it read the array <code>smb_simple_array</code> (which is here in fact a list of list).</p> <p>The module will compute surface mass balance at a frequency given by parameter <code>smb_simple_update_freq</code> (default is 1 year), and interpolate linearly the 4 parameters in time.</p> <p>If one has provided in input an \"icemask\" field, then this module will compute negative surface mass balance (-10 m/y) in place where posstive surface mass balance outside the mask were originally computed. The goal here is to prevent against overflowing in neibourghing catchements.</p>"},{"location":"modules/processes/smb_simple/#config-structure","title":"Config Structure","text":"<pre><code>smb_simple:\n  update_freq: 1.0 # help: Update the mass balance each X years (1)\n  file: param.txt # help: Name of the imput file for the simple mass balance model (time, gradabl, gradacc, ela, accmax)\n  array: [] # help: Time dependent parameters for simple mass balance model (time, gradabl, gradacc, ela, accmax)\n</code></pre>"},{"location":"modules/processes/smb_simple/#arguments","title":"Arguments","text":"Name Type Units Description Default Value update_freq float years Update the mass balance each X years 1.0 file string string Name of the input file for the simple mass balance model (time, gradabl, gradacc, ela, accmax) param.txt array list list Time dependent parameters for simple mass balance model (time, gradabl, gradacc, ela, accmax) []"},{"location":"modules/processes/smb_simple/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/texture/","title":"texture","text":"<p>This modules allows you to calculate ...</p>"},{"location":"modules/processes/texture/#config-structure","title":"Config Structure","text":"<pre><code>texture:\n  format: png # help=\"Format of the texture image (png, tif, or tiff)\"\n  model_path: ${hydra.runtime.cwd} # help=\"Name of the folder for the texture model (tf format)\"\n  verbosity: 30 # help=\"Python Logger verbosity level (10=DEBUG, 20=INFO, 30=WARNING, 40=ERROR, 50=CRITICAL)\"\n  divide_by_density: 1 # help=\"This parameter solves an imcompatibility (this option will be removed in the future)\"\n  resolution: -1 # help=\"This parameter solves an imcompatibility (this option will be removed in the future)\"\n\n# confirm this path still works for the module!\n</code></pre>"},{"location":"modules/processes/texture/#arguments","title":"Arguments","text":"Name Type Units Description Default Value format string string Format of the texture image (png, tif, or tiff) png model_path file path file path Name of the folder for the texture model (tf format) ${hydra.runtime.cwd} verbosity integer integer Python Logger verbosity level (10=DEBUG, 20=INFO, 30=WARNING, 40=ERROR, 50=CRITICAL) 30 divide_by_density boolean boolean This parameter solves an incompatibility (this option will be removed in the future) 1 resolution integer integer This parameter solves an incompatibility (this option will be removed in the future) -1"},{"location":"modules/processes/texture/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/thk/","title":"thk","text":"<p>This IGM module solves the mass conservation of ice to update the thickness from ice flow (computed from module <code>iceflow</code>) and surface mass balance (given any module that update <code>smb</code>). The mass conservation equation is solved using an explicit first-order upwind finite-volume scheme on the 2D working grid. With this scheme mass of ice is allowed to move from cell to cell (where thickness and velocities are defined) from edge-defined fluxes (inferred from depth-averaged velocities, and ice thickness in upwind direction). The resulting scheme is mass conservative and parallelizable (because fully explicit). However, it is subject to a CFL condition. This means that the time step (defined in module <code>time</code>) is controlled by parameter parameter <code>time_cfl</code>, which is the maximum number of cells crossed in one iteration (this parameter cannot exceed one), see the documentation of module <code>time</code>. A bit more details on the scheme are given in the following paper.</p> <pre><code>@article{jouvet2022deep,\n  author =        {Jouvet, Guillaume and Cordonnier, Guillaume and\n                   Kim, Byungsoo and L{\\\"u}thi, Martin and\n                   Vieli, Andreas and Aschwanden, Andy},\n  journal =       {Journal of Glaciology},\n  number =        {270},\n  pages =         {651--664},\n  publisher =     {Cambridge University Press},\n  title =         {Deep learning speeds up ice flow modelling by several\n                   orders of magnitude},\n  volume =        {68},\n  year =          {2022},\n  doi =           {10.1017/jog.2021.120},\n}\n</code></pre>"},{"location":"modules/processes/thk/#config-structure","title":"Config Structure","text":"<pre><code>thk:\n  slope_type: superbee # Help: Type of slope limiter for the ice thickness equation (godunov or superbee)\n  ratio_density: 0.910 # Help: density of ice divided by density of water\n  default_sealevel: 0.0 # Help: Default sea level if not provided by the user\n</code></pre>"},{"location":"modules/processes/thk/#arguments","title":"Arguments","text":"Name Type Units Description Default Value slope_type str string Type of slope limiter for the ice thickness equation (godunov or superbee) superbee ratio_density float dimensionless Density of ice divided by density of water 0.91 default_sealevel float meters Default sea level if not provided by the user 0.0"},{"location":"modules/processes/thk/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/time/","title":"time_igm","text":"<p>This IGM modules computes time step such that i) it satisfy the CFL condition (controlled by parameter <code>clf</code>) ii) it is lower than a given maximum time step (controlled by parameter <code>time_step_max</code>) iii) it hits exactly given saving times (controlled by parameter <code>time_save</code>). The module additionally updates the time \\(t\\) in addition to the time step.</p> <p>Indeed, for stability reasons of the transport scheme for the ice thickness evolution, the time step must respect a CFL condition, controlled by parameter <code>time_cfl</code>, which is the maximum number of cells crossed in one iteration (this parameter cannot exceed one). By default, we take <code>time_cfl</code> to 0.3. We additionally request time step to be upper-bounded by a user-defined parameter <code>time_save</code> (default: 1 year).</p> <p>Among the parameters of this module <code>time_start</code> and <code>time_end</code> defines the simulation starting and ending times, while <code>time_save</code> defines the frequency at which results must be saved (default: 10 years).</p> <p>A bit more details on the time step stability conditionsis given in the following paper.</p> <pre><code>@article{jouvet2022deep,\n  author =        {Jouvet, Guillaume and Cordonnier, Guillaume and\n                   Kim, Byungsoo and L{\\\"u}thi, Martin and\n                   Vieli, Andreas and Aschwanden, Andy},\n  journal =       {Journal of Glaciology},\n  number =        {270},\n  pages =         {651--664},\n  publisher =     {Cambridge University Press},\n  title =         {Deep learning speeds up ice flow modelling by several\n                   orders of magnitude},\n  volume =        {68},\n  year =          {2022},\n  doi =           {10.1017/jog.2021.120},\n}\n</code></pre>"},{"location":"modules/processes/time/#config-structure","title":"Config Structure","text":"<pre><code>time:\n  start: 2000.0\n  end: 2100.0\n  save: 10.0\n  cfl: 0.3\n  step_max: 1.0\n</code></pre>"},{"location":"modules/processes/time/#arguments","title":"Arguments","text":"Name Type Units Description Default Value start float years Start time of the simulation 2000.0 end float years End time of the simulation 2100.0 save float years Frequency of saving the simulation results 10.0 cfl float dimensionless CFL condition for time stepping 0.3 step_max float years Maximum time step allowed 1.0"},{"location":"modules/processes/time/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/vert_flow/","title":"Macro Rendering Error","text":"<p>File: <code>modules/processes/vert_flow.md</code></p> <p>UndefinedError: 'dict object' has no attribute 'vert_flow'</p> <pre><code>Traceback (most recent call last):\n  File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 688, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/jinja2/environment.py\", line 1301, in render\n    self.environment.handle_exception()\n  File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/jinja2/environment.py\", line 936, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 33, in top-level template code\n  File \"/home/bfinley/anaconda3/lib/python3.11/site-packages/jinja2/environment.py\", line 466, in getitem\n    return obj[argument]\n           ~~~^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'dict object' has no attribute 'vert_flow'\n</code></pre>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Before to start","text":"<ul> <li> <p>If you don't know anything about glacier processes, explore this great website. If you don't know anything about glacier evolution modeling, you may watch first this video, which gives some basics. </p> </li> <li> <p>OS: IGM was developed in a Linux environment but works on Windows and Mac. Windows user are strongly recommended to use WSL2 for using the GPU and the OGGM shop module. </p> </li> <li> <p>Disclaimer: IGM implements empirical physical laws, with an important amount of approximations (of any kind). Make sure to understand what you do, to explore key parameters, and interpret the results with care.</p> </li> </ul>"},{"location":"#how-to-start","title":"How to start","text":"<p>Running IGM consists of running a python script <code>igm_run</code>, which is made of functions of the IGM python package. This documentation will help you to understand the parameters and, set-up your model by listing the modules you need, customize your own modules for your application.</p> <ul> <li> <p>First, start with the 10-min video tutorial, or a longer IGS seminar presentation, and/or look at the in-progress IGM technical paper.</p> </li> <li> <p>Then, install an igm python environment on your system and starting with examples.</p> </li> <li> <p>Then, learn how to run IGM with module list and parameter setting (without extra coding), and explore the module documentation.</p> </li> <li> <p>Last, understand the code and write your own module code. </p> </li> </ul>"},{"location":"FAQ/","title":"FAQ","text":"<ul> <li>Ice is stuck on the border of the domain (no fluxes), what can I do?</li> </ul> <p>Set parameter exclude_borders_from_iceflow to True</p> <ul> <li>I see some numerical artifacts (e.g. waves) occurring when modeling glacier evolution, what can I do?</li> </ul> <p>Reduce the CFL parameter</p> <ul> <li>How to create/modify NetCDF files?</li> </ul> <p>There are many ways to prepare NetCDF files (matlab, python, GIS tools, ...). The NCO toolkit permits easy operations in command lines, e.g.</p> <pre><code>   ncks -x -v thk file.nc file.nc              # this removes the variable 'thk' from file.nc\n   ncks -v usurf file.nc file.nc               # this extracts the variable usurf from file.nc\n   ncap2 -h -O -s 'thk=0*thk' file.nc file.nc  # this does operations on file.nc, here force zero thk\n   ncrename -v apc,strflowctrl file.nc         # this renames varible apc to strflowctrl in file.nc\n</code></pre> <ul> <li>oggm_shop produces error on windows</li> </ul> <p>This is expected, OGGM is not supported on windows, however, modifying the tarfile.py file at line 2677 from name == member_name to name.replace(os.sep, '/') == member_name seems to fix the issue on Windows. Thanks Alexi Morin for proposing this workaround.</p>"},{"location":"Installation/","title":"Installation","text":"<p>IGM is a Python package, which works on any OS on </p> <ul> <li>CPU (not computationally efficient, but fine for small applications like individual glaciers),</li> <li>GPU (the most computationally efficient way, especially relevant for large-scale and high-resolution applications). </li> </ul> <p>IGM can be installed with the </p> <ul> <li>the main version for stable application (the latest available tag), not all modules,</li> <li>the development version to get the latest feature with all modules (at the possible price of unrevealed bugs). </li> </ul> <p>Both versions are now on the same (main) branch. IGM is rapidly changing, keep track of updates on the release page for the tagged versions or/and on this page for the development version.</p> <p>Note that the igm package installs most of dependent packages, but not all. For using some post-processing modules, the user has to install additional packages (e.g., mayavi, plotly, ect.).</p> <p>We first describe the installation in Linux (the preferred OS), and then on Windows and Mac.</p>"},{"location":"Installation/#linux","title":"Linux","text":""},{"location":"Installation/#windows","title":"Windows","text":""},{"location":"Installation/#mac","title":"Mac","text":""},{"location":"Installation/#troubleshooting","title":"Troubleshooting","text":"<p>Main source of issues are linked to Tensorflow and the use of GPU. Hopefully, the installation is significantly easier since tensorflow 2.14.0 since it can install all necessary GPU/cuda dependent packages with the right version automatically. Note that to ensure smooth usage of GPU with cuda and tensorflow libraries, one has to make sure that i) cuda ii) cudnn iii) tensorflow are compatible, and your Nvidia driver is compatible with the version of cuda. Such incompatibility is the most common source of issue. </p> <p>For instance, it is possible do install tensorflow-2.12.0 by setting <code>tensorflow==2.12.0</code> in the setup.py and</p> <pre><code>conda install -c conda-forge cudatoolkit=11.8.0\npip install nvidia-cudnn-cu11==8.6.0.163\n\nmkdir -p ${CONDA_PREFIX}/etc/conda/activate.d\nD=${CONDA_PREFIX}/etc/conda/activate.d/env.sh\necho 'export PYTHONNOUSERSITE=1' &gt;&gt; $D\necho 'export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${CONDA_PREFIX}/lib' &gt;&gt; $D\necho 'export CUDNN_PATH=$(dirname $(python -c \"import nvidia.cudnn;print(nvidia.cudnn.__file__)\"))' &gt;&gt; $D\necho 'export LD_LIBRARY_PATH=$CONDA_PREFIX/lib/:$CUDNN_PATH/lib:$LD_LIBRARY_PATH' &gt;&gt; $D\n</code></pre>"},{"location":"Running/","title":"Running","text":"<p>Assuming you have installed the right igm environment, the glacier evolution model IGM can be run via the command <code>igm_run</code>: define     igm_run --RGI-ID RGI60-11.01450 --time_start 2023 --time_end 2100</p> <p>where parameters are given in command line as above or in a file params.json (recommended) like </p> <pre><code>{\n  \"modules_preproc\": [\"oggm_shop\"],\n  \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\"],\n  \"modules_postproc\": [\"write_ncdf\",\"plot2d\",\"print_info\",\"print_comp\"],\n  \"oggm_RGI_ID\": \"RGI60-11.01238\",\n  \"time_start\": 2023.0,\n  \"time_end\": 2100.0\n}\n</code></pre> <p>and igm_run.py is a short python script located in the root directory that perform the following steps (check the code for more details):</p> <ul> <li>collect parameters into <code>params</code> object, including the ordered list of modules <code>modules</code>,</li> <li>define a <code>state</code> object that contains all the data (e.g. ice thickness),</li> <li>initialize all model components in turn,</li> <li>update all model components in turn within a time loop from start to end times,</li> <li>finalize all model components in turn.</li> </ul> <p>Therefore running IGM requires to define parameters <code>params</code>, which includes first-of-all the list of wished IGM modules.</p> <p>IGM can also take the parameter file as input as follows: <code>igm_run --param_file params1.json</code></p>"},{"location":"Running/#parameters-params-full-list","title":"Parameters (<code>params</code>, full list)","text":"<p>IGM has a few core parameters:</p> short long default help <code>--param_file</code> <code>params.json</code> Parameter file <code>--modules_preproc</code> <code>[\"prepare_data\"]</code> List of pre-processing modules <code>--modules_process</code> <code>[\"iceflow\",\"time\",\"thk\"]</code> List of processing modules <code>--modules_postproc</code> <code>[\"write_ncdf\",\"print_info\"]</code> List of post-processing modules <code>--logging</code> <code>False</code> Activate the logging <p>and many other module-specific parameters, see the full list of parameters or the  module documentation for the meaning and default values of the parameters of each module. Parameters passed in command line override those passed in the jon parameter file, which override the default IGM parameters.</p>"},{"location":"Running/#modules-modules","title":"Modules (modules)","text":"<p>IGM is organized module-wise. Each user must pick a sequence of existing pre-processing, processing, post-processing and/or user-made modules she/he wishes to have for her/his application (check at the module documentation. Each module implements all least 4 functions for module-specific parameter definition, initialization, update and finalization, which are called by <code>igm_run</code>. This section helps to chose the appropriate module. First one needs pre-processing modules:</p> <ul> <li>For modelling individual present-day glacier, the best is to use the OGGM-based <code>prepare_data</code> module, which take care of downloading all the gridded data appropriatly. In that case, the <code>modules_preproc</code> in the json parameter file look like:  <pre><code>   \"modules_preproc\": [\"oggm_shop\"], \n</code></pre></li> <li> <p>Alternatively to module <code>oggm_shop</code>, one may load the data directly NetCDF file (with module <code>load_ncdf</code>), tif file (with module <code>load_tif</code>) or from analytical formula for synthetic glacier tests (<code>synthetic</code>).</p> </li> <li> <p>Optionally the additional module <code>optimize</code> permits to do data assimilation seeking for ice thickness distribution, ice flow parameters that yield the best fit with data (e.g. surface ice speeds). In that case, the `modules_preproc in the json parameter file look like:  <pre><code>\"modules_preproc\": [\"prepare_data\",\"optimize\"],\n</code></pre> Second one needs to define processing modules:</p> </li> <li> <p>The minimum to have as processing is the combination of ice flow (module <code>iceflow</code>), ice thickness (module <code>thk</code>), and time step (module <code>time</code>):</p> </li> </ul> <pre><code>  \"modules_process\": [\"iceflow\"\",\"time\",\"thk\"],\n</code></pre> <ul> <li>However, it sounds reasonable to add at least a surface mass balance module (e.g. <code>smb_simple</code>), and other components we like to have (e.g. computation of vertical velocity, particle trajectory, climate, enthalpy, ...) making sure to respect a logical order, i.e., </li> </ul> <pre><code>  \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\",\"vert_flow\",\"particles\"],\n</code></pre> <p>Then, one needs post-processing modules to output the results of the model, e.g. this line will permit to write model output in NetCDF files, make 2D plots, print basic informatinN (e.g. ice volume), and produce a nice 3D animation of the run at the end:</p> <pre><code>  \"modules_postproc\": [ \"write_ncdf\", \"plot2d\", \"print_info\",  \"anim_mayavi\" ]\n</code></pre> <p>Lastly, one often needs to customize the code for specific applications. This is easy to do so with IGM, e.g. for imposing own climate forcing, defining own surface mass balance, ... For that purpose, implement your module in a separate file my_mod.py, and add it to the workflow</p> <p><pre><code>  \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\",\"my_mod\"],\n</code></pre> then, the module will be automatically loaded by <code>igm_run</code> when being executed.</p>"},{"location":"about/credits_and_references/","title":"References","text":"<p>There is currently an in-progress IGM technical paper that will give you an overview of the physical components, modules, and capabilities of IGM.</p> <p>If you use IGM in publications, make sure to cite one of the following papers and the code version you used.</p> <p><pre><code>@article{IGM,\n    author       = \"Jouvet, Guillaume and Cordonnier, Guillaume and Kim, Byungsoo and L\u00fcthi, Martin and Vieli, Andreas and Aschwanden, Andy\",  \n    title        = \"Deep learning speeds up ice flow modelling by several orders of magnitude\",\n    DOI          = \"10.1017/jog.2021.120\",\n    journal      = \"Journal of Glaciology\",\n    year         =  2021,\n    pages        = \"1\u201314\",\n    publisher    = \"Cambridge University Press\"\n}\n</code></pre> <pre><code>@article{IGM-inv,\n    author       = \"Jouvet, Guillaume\",\n    title        = \"Inversion of a Stokes ice flow model emulated by deep learning\",\n    DOI          = \"10.1017/jog.2022.41\",\n    journal      = \"Journal of Glaciology\",\n    year         = \"2022\",\n    pages        = \"1--14\",\n    publisher    = \"Cambridge University Press\"\n}\n</code></pre> <pre><code>@article{IGM-PINN,\n    title={Ice-flow model emulator based on physics-informed deep learning},\n    author={Jouvet, Guillaume and Cordonnier, Guillaume},\n    journal={Journal of Glaciology},\n    pages={1--15},\n    year={2023},\n    publisher={Cambridge University Press},\n    doi={10.1017/jog.2023.73}\n}\n</code></pre></p>"},{"location":"about/credits_and_references/#acknowledgements","title":"Acknowledgements","text":"<p>I greatly thank Guillaume Cordonnier for his valuable help with the TensorFlow implementation. The Parallel Ice Sheet Model has greatly inspired the naming of variables, as well as the format of input and output NetCDF files.</p>"},{"location":"about/gpus/","title":"Graphical Processing Units (GPUs)","text":"<p>IGM works fine on CPU for small computational domains (typically individual glaciers). In contrast, GPUs will be very advantageous to treat very large computational grids (typically large networks of glaciers) as IGM naturally takes further benefit from parallelism. </p> Resolution Minimum computational ressource 0.25 K: 256 x 192 pixel CPU 1 K   : 1024 x 768 pixel laptop GPU    e.g., RTX A4000 4 K   : 3840 x 2160 pixel excellent GPU  e.g., RTX 4090 <p>To illustrate this, I modeled the ice dynamics and glacier evolution over New Zealand by forcing the mass balance with an ELA oscillating between 1000 and 2000 meters a.s.l. The 1000-year-long simulation took about 1.5 hours on the Nvidia RTX 3090 GPU with a 640x700 km computational domain at 200 meters of resolution (i.e. 3200x3500 grid). The animation can be visualized on this link.</p>"},{"location":"about/tensorflow/","title":"Tensorflow","text":"<p>IGM fully relies on TensorFlow 2.0 library for computational efficiency on GPU. All variables (e.g. ice thickness) are TensorFlow tensor objects, which can only be modified using TensorFlow operations. All these operations are vectorial, i.e. they apply simultaneously to all entries of 2D gridded fields, which is key for parallel and efficient execution. This means that one must avoid any sequential operations (typically loop of indices of 2D arrays), and favour TensorFlow (optimized) operations between large arrays (e.g. neural networks). </p> <p>At first sight, a lot of TensorFlow functions look similar to Numpy ones, one can simply do operations by changing numpy to tensorflow, e.g. 'tf.zeros()' instead of 'np.zeros()' with 'import tensorflow as tf' instead of 'import numpy as np'. E.g. Tensorflow operations look like: <pre><code>state.topg  = tf.zeros_like(state.usurf)                                  # define Variable Tensor\nstate.smb   = tf.where(state.usurf &gt; 4000, 0, state.smb)                   # Imposes zero mass balance above 4000 m asl.\nstate.usurf = state.topg + state.thk                                       # Update surface topography with new ice thickness\nstate.smb   = tf.clip_by_value( (state.usurf - ela)*grad , -100, 2.0 )     # Define linear smb wrt z, with capping value\nu = tf.concat( [u[:, 0:1], 0.5 * (u[:, :-1] + u[:, 1:]), u[:, -1:]], 1 )   # work on straggered grid\n</code></pre> In fact, there are two kinds of tensor that are used in IGM. First, \"EagerTensor\" (as shown above) can make many operations, however, we can NOT change specific tensor entries (slicing): <pre><code>tensor = tf.ones((500,300))  \ntensor = (2*tensor + 200)**2\ntensor[1,2] = 5 # WILL NOT WORK\n</code></pre> As a workaround, one uses \"tf.Variable\" that permits to slice, however, the assignment is slightly different, it can not be done with \"=\", but with the \"assign\" function: <pre><code>tensor = tf.Variable(tf.ones((500,300)))\ntensor.assign( (2*tensor + 200)**2 )\ntensor[1,2].assign( 5 ) # WORKS !\n</code></pre> IGM combines both types of tensors, so make sure to identify what is your type, other TF will produce an error.</p> <p>For the best computational efficiency, it is crucial to keep all variables and operations within the TensorFlow framework without using Numpy (to avoid unnecessary transfers between GPU and CPU memory). There is the possibility to generate TensorFlow function using Numpy code, check at this page.</p> <p>The best way to learn how to code with tensorflow within the context of IGM is to explore module codes, or to look at examples.</p>"},{"location":"about/transition-IGM-2-to-3/","title":"Guideline for transitioning IGM v2 to v3","text":""},{"location":"about/transition-IGM-2-to-3/#parameter-handling","title":"Parameter handling","text":""},{"location":"about/transition-IGM-2-to-3/#hydra-library-replaces-parser","title":"<code>hydra</code> library replaces <code>parser</code>","text":"<p>Parameters handed with library <code>parser</code> are nor handled with library <code>hydra</code>. Parameter file formerly JSON file <code>param.json</code> is now changed into YAML file <code>experiment/params.yaml</code> following <code>yaml</code> standard. Delegating the handling of parameters to <code>hydra</code> has permitted major simplification of the core IGM code. Running IGM now consists of running</p> <p><pre><code> igm_run +experiment=params \n</code></pre> where parameters can be changed within the params, or can be overidden like : <pre><code> igm_run +experiment=params core.hardware.gpu_info=False core.print_params=False\n</code></pre></p>"},{"location":"about/transition-IGM-2-to-3/#hierachical-parameters","title":"Hierachical parameters","text":"<p>Another consequence is that the parameters are now hierarchically organized in 2 ways:   - The structure of folder where default parameter are stored in folder <code>igm/igm/conf</code>, which is separated from the code in folder <code>igm/igm</code>:   ``` core.yaml \u251c\u2500\u2500 inputs  \u2502   \u2514\u2500\u2500 local.yaml \u2502   \u2514\u2500\u2500 .... \u251c\u2500\u2500 processes  \u2502   \u2514\u2500\u2500 iceflow.yaml \u2502   \u2514\u2500\u2500 .... \u2514\u2500\u2500 outputs \u2502   \u2514\u2500\u2500 plot2d.yaml \u2502   \u2514\u2500\u2500 .... <pre><code>  - In the code, all parameters are accessible through the object `cfg`, e.g `cfg.processes.enthalpy.ref_temp` is a parameter associated with the `enthalpy` processes module.\n\n### Parameters naming change\n\nPaarameter name have been slightly changed: Before all parameters had a first keyword like `iflo` to indicate it was a parameter associated with `iceflow` module. Now, all parameters are sorted anyway attributes, therefore, the keyword was no longer used, and was removed. \n\nAs an example `time_start` is now accessible with `processes.time.start`, ...\n\nIn the `iceflow` module, parameters were re-oragnized significantly (especially to make them hierarchically organized), however, we provide with a folder/script/table of correspondance to modify former json file into new yaml one.\n\n### Example of new parameter file\n\nHere is what look like the new parameter file : \n\n```yaml\n# @package _global_\n\ncore:\n  url_data: \"https://www.dropbox.com/scl/fo/8ixpy27i67s04bp7uixoq/h?rlkey=0ye7rd4zkcqfhvzx7suunw3bk&amp;dl=0\"\n\ndefaults:\n  - override /input: [load_ncdf]\n  - override /modules: [smb_simple, iceflow, time, thk]\n  - override /output: [write_ncdf, plot2d]\n\ninputs:\n  load_ncdf:\n    input_file: data/input.nc\n\nprocesses:\n  iceflow:\n    iceflow:\n      init_slidingco: 0.0595\n  time:\n    start: 1880.0\n    end: 2020.0\n    save: 5.0 \n\noutputs:\n  plot2d:\n    live: true\n</code></pre></p> <p>The above file will be read by hydra in IGM, and has the following strucuture:</p> <ul> <li><code>core</code> includes all parameters that are specific to core IGM run, e.g. logging, if we want to download data priori to run, GPU related, ...</li> <li><code>defaults</code> will list the inputs, processes, and outputs modules.</li> <li><code>inputs</code> give the parameters tot override the defaults for input modules.</li> <li><code>processes</code> give the parameters tot override the defaults for processes modules.</li> <li><code>outputs</code> give the parameters tot override the defaults for output modules.</li> </ul>"},{"location":"about/transition-IGM-2-to-3/#new-structure-of-working-folder","title":"New structure of working folder","text":"<p>The working folder as follows with one    - folder <code>experiment</code> containing the parameter files,   - folder <code>data</code> for input data if any,    - folder <code>user</code> containing user/custom python functions/modules,    - folder <code>output</code> or <code>multirun</code> containing the results of the IGM runs.</p> <p>This will look like :  <pre><code>\u251c\u2500\u2500 experiment \n\u2502   \u2514\u2500\u2500 params.yaml\n\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 ...\n\u2514\u2500\u2500 user\n\u2502   \u251c\u2500\u2500 code\n\u2502   \u2502   \u2514\u2500\u2500 processes\n\u2502   \u2502       \u2514\u2500\u2500 mymodule.py\n\u2502   \u2514\u2500\u2500 conf\n\u2502   \u2502   \u2514\u2500\u2500 processes\n\u2502   \u2502       \u2514\u2500\u2500 mymodule.yaml\n\u2514\u2500\u2500 output\n\u2502   \u251c\u2500\u2500 2025-03-06\n\u2502   \u2502   \u2514\u2500\u2500 15-43-37\n\u2502   \u2502   \u2514\u2500\u2500 15-44-07\n\u2502   \u2502       \u2514\u2500\u2500 output.nc\n\u2502   \u2502       \u2514\u2500\u2500 ......\n</code></pre></p>"},{"location":"about/transition-IGM-2-to-3/#re-naming-of-modules","title":"Re-naming of modules:","text":"<p>Former <code>preprocess</code>, <code>process</code>, and <code>postprocess</code> module types were renamed <code>input</code>, <code>modules</code>, <code>output</code>. <code>input</code> only have a <code>run</code> method, while <code>output</code> has <code>initialize</code> and <code>update</code> like modules.</p>"},{"location":"about/transition-IGM-2-to-3/#integration-and-exclusion-of-former-modules","title":"Integration and exclusion of former modules","text":"<ul> <li> <p>Former modules <code>anim_mayavi</code>, <code>anim_plotly</code>, <code>anim_video</code> were externalized from igm, and put in <code>utils</code>. These one were purely postprocessing, and were run at the very end. For simplicity, there were externalized.</p> </li> <li> <p>Modules like <code>print_comp</code>, or <code>print_info</code>were integrated to the core</p> </li> </ul>"},{"location":"about/transition-IGM-2-to-3/#transition-from-igm-2xx-to-igm-300","title":"Transition from IGM 2.X.X to IGM 3.0.0","text":"<p>From a pure user point of view, migrating to IGM 3, is mainly changing former parameter file <code>params.json</code> into <code>experiment/params.yaml</code>. To help with this, we have made utility is <code>json_to_yaml.py</code>.</p>"},{"location":"about/transition-IGM-2-to-3/#running-multiple-runs","title":"Running multiple runs","text":"<p>A great advantage of hydra is the posibility it gives to for running ensemble runs, e.g. the foolowing line permits to run sequentially two runs with the 2 sets of parameters: <pre><code>igm_run -m +experiment=params processes.time.end=2080,2110\n</code></pre> or if one supply two parameter files (params1, params2): <pre><code>igm_run -m +experiment=params1,params2\n</code></pre> or doing a grid search ovr 3x2 parameters <pre><code>igm_run -m +experiment=params processes.time.start=1900,1910,1920 processes.time.end=2080,2110\n</code></pre> Note that in that case, the output folder will be named <code>multirun</code> instead of <code>output</code>.</p>"},{"location":"about/transition-IGM-2-to-3/#custom-modules-now-called-user","title":"Custom modules (now called \"user\")","text":"<p>User modules are very useful as soon as we need to customize applications, they can be used to customize inputs, processes or outputs methods. To create such a user module, you need to create (or complete) the folder <code>user</code> located at the root of your working directory as follows (respect the hierarchy): <pre><code>\u2514\u2500\u2500 user\n    \u251c\u2500\u2500 code\n    \u2502   \u2514\u2500\u2500 inputs \n    \u2502   \u2502   \u2514\u2500\u2500 my_inputs_module\n    \u2502   \u2502       \u2514\u2500\u2500 my_inputs_module.py \n    \u2502   \u2514\u2500\u2500 processes \n    \u2502   \u2502   \u2514\u2500\u2500 my_processes_module\n    \u2502   \u2502       \u2514\u2500\u2500 my_processes_module.py \n    \u2502   \u2514\u2500\u2500 outputs \n    \u2502       \u2514\u2500\u2500 my_outputs_module\n    \u2502           \u2514\u2500\u2500 my_outputs_module.py \n    \u2514\u2500\u2500 conf\n        \u2514\u2500\u2500 inputs\n            \u2514\u2500\u2500 my_inputs_module.yaml \n        \u2514\u2500\u2500 processes\n            \u2514\u2500\u2500 my_processes_module.yaml \n        \u2514\u2500\u2500 outputs\n            \u2514\u2500\u2500 my_outputs_module.yaml \n</code></pre> where <code>my_processes_module.py</code> has the following structure (and require to define function <code>initialize</code>, <code>update</code>, and <code>finalize</code>):</p> <p>and access to the parameter <pre><code>def initialize(cfg,state):\n  ... \n\ndef update(cfg,state):\n  cfg.processes.clim_aletsch.time_resolution\n  ... \n\ndef finalize(cfg,state):\n  pass\n</code></pre> while <code>my_inputs_module.py</code> and <code>my_outputs_module.py</code> has the following structure (and require to define function <code>run</code>) and access to the parameter</p> <p><pre><code>def run(cfg, state):\n  ...\n</code></pre> On the other end, parameter files located in <code>conf/inputs</code>, <code>conf/processes</code>, and <code>conf/outputs</code> look like  <pre><code>update_freq: 1\ntime_resolution: 365\n</code></pre> or in case there is no parameter (the file must exist as follows even if no parameter are defined): <pre><code>null\n</code></pre> It must be stressed that the user modules override the official one, therefore, if you call a module that has the same name of an official one, the user one will be retained, and the official one will be ignored.</p>"},{"location":"about/transition-IGM-2-to-3/#misc","title":"MISC","text":"<ul> <li>write_particles is now part of the particule module</li> <li>oggm_shop is now only tking care of downloading the data, and putting the data ready for IGM, therfore, oggm_shop must be followed by <code>load_ncdf</code>, or <code>local</code></li> <li>A new I/O module <code>local</code> as introduced to replace <code>load_XXX</code> and <code>write_XXX</code>: <code>local</code> uses library <code>xarray</code> that is more powerfull and can load both <code>netcdf</code> and <code>tif</code>.</li> </ul>"},{"location":"about/user_modules/","title":"User modules","text":"<p>It is fairly simple to write your own module in a separate python file and include it in the workflow, e.g. to force a climate and/or surface mass balance model specific to an application. For that, one needs to undestand how IGM is coded.</p>"},{"location":"about/user_modules/#coding-structure","title":"Coding structure","text":"<p>A closer look at main script <code>igm_run.py</code> shows the following main structure:</p> <ul> <li><code>run</code> all inputs modules</li> <li><code>initialize</code> all processes modules</li> <li><code>initialize</code> all outputs modules</li> <li>for all time steps:<ul> <li><code>update</code> all processes modules</li> <li><code>run</code> all outputs modules</li> </ul> </li> <li><code>finalize</code> all processes modules</li> </ul> <p>where <code>inputs</code> modules implement a <code>run</code> function, <code>processes</code> modules implement a <code>initialize</code>, <code>update</code>, <code>finalize</code> function, and <code>outputs</code> modules implement  <code>initialize</code> and <code>run</code> functions.</p> <p>Similarly to existing IGM ones, a user-defined module <code>my_module</code> can be implemented and be automatically loaded when <code>igm_run</code> is executed providing <code>my_module</code> and the path to its parameter file being called as a module (see the example below). Building a user module consists of filling the following folder with the hierachical structure:</p> <pre><code>\u2514\u2500\u2500 user\n\u2502   \u251c\u2500\u2500 code\n\u2502   \u2502   \u2514\u2500\u2500 input\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 myinput.py\n\u2502   \u2502   \u2514\u2500\u2500 processes\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 myprocess.py\n\u2502   \u2502   \u2514\u2500\u2500 outputs\n\u2502   \u2502       \u2514\u2500\u2500 myoutput.py\n\u2502   \u2514\u2500\u2500 conf\n\u2502   \u2502   \u2514\u2500\u2500 input\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 myinput.yaml\n\u2502   \u2502   \u2514\u2500\u2500 processes\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 myprocess.yaml\n\u2502   \u2502   \u2514\u2500\u2500 outputs\n\u2502   \u2502       \u2514\u2500\u2500 myoutput.yaml\n</code></pre> <p>Hereabove, the code files are expected to define functions <code>run(cfg,state)</code>, <code>initialize(cfg,state)</code>, <code>update(cfg,state)</code>, and/or <code>finalize(cfg,state)</code>, where <code>cfg</code> permits to access any parameters (e.g <code>cfg.processes.enthalpy.ref_temp</code> is a parameter associated with the <code>enthalpy</code> processes module), while <code>state</code> permits to access any  variables describing the glacier state at a time t (e.g <code>state.thk</code> is the variable describing the distributed 2D ice thickness). All these variable are TensorFlow 2.0 Tensors. Using Tensorflow is key to making computationally efficient operations, especially on GPU. Any variables can be accessed/modified via state.nameofthevariable. Variables names are summarized here.</p>"},{"location":"about/user_modules/#example","title":"Example","text":"<p>For instance, to implementation of the mass balance function 'sinus' with an oscillating ELA, you may create a module <code>mysmb</code> in a file <code>mysmb.py</code>:</p> <pre><code>def initialize(cfg,state):\n    pass\n\ndef update(cfg,state): \n    ELA = cfg.processes.mysmb.meanela + \\\n          750*math.sin((state.t/100)*math.pi) \n    state.smb  = state.usurf - ELA\n    state.smb *= tf.where(state.smb&lt;0, 0.005, 0.009)\n    state.smb  = tf.clip_by_value(state.smb, -100, 2) \n\ndef finalize(cfg,state):\n    pass\n</code></pre> <p>and a parameter file <code>mysmb.yaml</code> containing the default value:</p> <pre><code>mysmb:\n  meanela: 3200\n</code></pre> <p>Then, in the parameter file <code>params.yaml</code>, it remains i) to list the user module so that the code will be found ii) to list the parameter file so that it will be added to the other parameters as follows:</p> <pre><code>defaults:\n\n  - /user/conf/processes@processes.mysmb: mysmb\n  ...\n  - override /processes:  \n     - mysmb\n     - iceflow\n     - time\n     - thk \n  ...\n</code></pre> <p>Note that the 3 functions (initialize, update, finalize) must be defined even if some are not doing anything (just use <code>pass</code>). You may find coding inspiration / examples looking at the code of IGM modules.</p>"},{"location":"about/user_modules/#overriding-modules","title":"Overriding modules","text":"<p>[TO UPDATE] Sometime, it may happen that you would like to bring a minor modification to an existing module. If so, no need to copy/paste the entire module and bring your modification, you may simply define a module with the same name existingmodule.py that contains only the function you would like to modify. All other function will be taken from the orginal module. For instance, the <code>aletsch-1880-2100</code> module implements a special seeding strategy for the particle module in user-defined particles.py.  </p>"},{"location":"about/user_modules/#sharing-your-module","title":"Sharing your module","text":"<p>[TO UPDATE] If you have developed a module that you believe may be useful to the community and be shared within igm package, read this section carefully. First, give a meaningful name to your module, and match the structure of other existing modules. Name modulename.py, modulename.md, modulename.yaml the python, the documentation file, and the parameter file, respectively. Once all of this is achieved, you may contact IGM's developper team or initiate a pull request.</p>"},{"location":"about/variables/","title":"Variables","text":"<p>Whenever this is possible, IGM adopts name convention of PISM. Here is a minimal list of key variables:</p> Variable names Shape Description Unit t () Time variable (scalar) y dt () Time step (scalar) y x,y (nx) Coordinates vectors m thk (ny) Ice thickness m topg (ny,nx) Basal topography (or bedrock) m usurf (ny,nx) Surface topography m smb (ny,nx) Surface Mass Balance m/y ice-eq ubar (ny,nx) x- depth-average velocity of ice m/y vbar (ny,nx) y- depth-average velocity of ice m/y U (nz,ny,nx) x-horiz. 3D velocity field of ice m/y V (nz,ny,nx) y-horiz. 3D velocity field of ice m/y W (nz,ny,nx) z-vert.  3D velocity field of ice m/y arrhenius (ny,nx) Arrhenius Factor MPa^(-3) y^(-1) slidingco (ny,nx) Sliding Coefficient \\(\\(MPa m^{-1/3} y^(-1/3)\\)\\) divflux (ny,nx) Divergence of the flux m/y icemask (ny,nx) Mask to restrict the smb comp. - dtopgdt (ny,nx) Erosion rate m/y xpos,ypos (nb particles) x,y position of particles m rhpos (nb particles) rel. pos of particles in ice column m air_temp (nt,ny,nx) seasonal air temperature 2 m above ground \u00b0C precipitation (nt,ny,nx) seasonal precipitation (water eq) kg m^(-2) y^(-1)"},{"location":"examples/Examples/","title":"Examples","text":"<p>Once IGM is installed, it is time to make your first runs. The best and quickest way to get to know IGM is to run given examples. For that, you may run the <code>quick-demo</code> presented hereafter, or download the following repository that contains an gallery of ready-to-run setups (incl. parameter file, data, user modules if any), check at individual instructions:</p> <pre><code>git clone https://github.com/instructed-glacier-model/igm-examples\n</code></pre> <p>then you may simply run <code>igm_run +experiment=params</code> (or adapt <code>params</code> to the name of the file) in each folder to run the example.</p>"},{"location":"examples/Examples/#quick-demo","title":"Quick demo","text":"<p>Copy paste the following YAML parameter file (named it <code>params.yaml</code>), put in a folder <code>experiment</code>, and then run the comand <code>igm_run +experiment=params</code>. By doing so, you will model Glacier with RGI ID <code>RGI60-11.01450</code> (the great Aletsch Glacier, Switzerland) from 2020 to 2100 assuming an increase of temperature of 4 degree by 2100 relative to 1960-1990. The run i) use module <code>oggm_shop</code> to download all the data via OGGM, ii) run a forward model that combine OGGM-based SMB model, and IGM-based iceflow, iii) write and plot the results in live time. Warning: this setup is just an example, that should not be intepreted (as it has not been validated against past period). After running, this example, you may explore different glaciers picking a different ID (check the GLIMS Viewer), explore different parameters, explore additional modules, ...</p> params.yaml<pre><code># @package _global_\n\ndefaults:\n  - override /inputs: \n    - oggm_shop\n  - override /processes: \n    - clim_oggm\n    - smb_oggm\n    - iceflow\n    - time\n    - thk\n  - override /outputs: \n    - write_ncdf\n    - plot2d\n\ninputs:\n  oggm_shop:\n    RGI_ID: \"RGI60-11.01450\"\n    RGI_version: 6\n\nprocesses:\n  clim_oggm:\n    clim_trend_array: \n      - [\"time\", \"delta_temp\", \"prec_scal\"]\n      - [ 2020,           0.0,         1.0]\n      - [ 2100,           4.0,         1.0]\n  iceflow:\n    iceflow:\n      init_slidingco: 0.25\n  time:\n    start: 2200.0\n    end: 2100.0\n    save: 10.0\n\noutputs:\n  plot2d:\n    live: true\n</code></pre>"},{"location":"examples/aletsch_basic/","title":"Setup","text":"config.yaml<pre><code>modules_preproc:\n  - load_ncdf\nmodules_process:\n  - smb_simple\n  - iceflow\n  - time\n  - thk\n  - vert_flow\n  - particles\nmodules_postproc:\n  - write_ncdf\n  - plot2d\n  - print_info\n  - print_comp\nsmb_simple_array:\n  - [\"time\", \"gradabl\", \"gradacc\", \"ela\", \"accmax\"]\n  - [1900, 0.009, 0.005, 2800, 2.0]\n  - [2000, 0.009, 0.005, 2900, 2.0]\n  - [2100, 0.009, 0.005, 3300, 2.0]\ntime_start: 1900.0\ntime_end: 2000.0\nurl_data: https://www.dropbox.com/scl/fo/kd7dix5j1tm75nj941pvi/h?rlkey=q7jtmf9yn3a970cqygdwne25j&amp;dl=0\nlncd_input_file: data/input.nc\nplt2d_live: true\ntime_save: 10.0\n</code></pre>"},{"location":"examples/quick_demo/","title":"Quick demo","text":""},{"location":"examples/quick_demo/#macros-plugin-environment","title":"Macros Plugin Environment","text":""},{"location":"examples/quick_demo/#general-list","title":"General List","text":"<p>All available variables and filters within the macros plugin:</p> Variable Type Content extra dict version [dict] config MkDocsConfig {'config_file_path': '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/mike-mkdocssklj6t6k.yml', 'site_name': 'Instructed Glacier Model (IGM)', 'nav': [{'Home': 'index.md'}, {'Installation': [{'Quick Start': 'installation/quick_start.md'}, {'Other': [{'Nvidia Drivers': 'installation/other/nvidia_drivers.md'}, {'Virtual Environments': 'installation/other/virtual_environment.md'}, {'WSL Windows': 'installation/other/wsl_windows.md'}]}]}, {'Getting Started': [{'Using Hydra': [{'Introduction': 'hydra/introduction.md'}, {'Configuration': 'hydra/configuration.md'}, {'Distributed Computing': 'hydra/distributed_computing.md'}]}, {'Examples': 'examples/Examples.md'}]}, {'Modules': [{'What are modules?': 'modules/introduction.md'}, {'Input': [{'local': 'modules/inputs/local.md'}, {'load_ncdf': 'modules/inputs/load_ncdf.md'}, {'load_tif': 'modules/inputs/load_tif.md'}, {'oggm_shop': 'modules/inputs/oggm_shop.md'}]}, {'Processes': [{'avalanche': 'modules/processes/avalanche.md'}, {'clim_glacialindex': 'modules/processes/clim_glacialindex.md'}, {'clim_oggm': 'modules/processes/clim_oggm.md'}, {'enthalpy': 'modules/processes/enthalpy.md'}, {'gflex': 'modules/processes/gflex.md'}, {'glerosion': 'modules/processes/glerosion.md'}, {'iceflow': 'modules/processes/iceflow.md'}, {'particles': 'modules/processes/particles.md'}, {'read_output': 'modules/processes/read_output.md'}, {'rockflow': 'modules/processes/rockflow.md'}, {'smb_accpdd': 'modules/processes/smb_accpdd.md'}, {'smb_oggm': 'modules/processes/smb_oggm.md'}, {'smb_simple': 'modules/processes/smb_simple.md'}, {'texture': 'modules/processes/texture.md'}, {'thk': 'modules/processes/thk.md'}, {'time': 'modules/processes/time.md'}, {'vert_flow': 'modules/processes/vert_flow.md'}]}, {'Output': [{'local': 'modules/outputs/local.md'}, {'write_ncdf': 'modules/outputs/write_ncdf.md'}, {'write_tif': 'modules/outputs/write_tif.md'}, {'write_ts': 'modules/outputs/write_ts.md'}, {'plot2d': 'modules/outputs/plot2d.md'}]}, {'User': 'about/user_modules.md'}]}, {'About': [{'Transitioning from IGM 2 to 3': 'about/transition-IGM-2-to-3.md'}, {'Graphical Processing Units (GPUs)': 'about/gpus.md'}, {'Tensorflow': 'about/tensorflow.md'}, {'Crediting IGM': 'about/credits_and_references.md'}, {'Variables': 'about/variables.md'}]}], 'pages': None, 'exclude_docs': None, 'draft_docs': None, 'not_in_nav': None, 'site_url': 'https://jouvetg.github.io/igm-doc.github.io/2.2.3', 'site_description': 'Run your own glacier simulations in a fast, accurate, and user-friendly way.', 'site_author': None, 'theme': Theme(name='material', dirs=['/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/docs/material/overrides', '/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/material/templates', '/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/mkdocs/templates'], static_templates={'404.html', 'sitemap.xml'}, name='material', locale=Locale('en'), language='en', direction=None, features=['content.code.copy', 'content.code.annotate', 'content.code.select', 'navigation.path', 'navigation.instant.progress', 'navigation.tabs', 'navigation.footer', 'toc.integrate', 'toc.follow', 'search.highlight', 'search.suggest'], font={'text': 'Inter', 'code': 'Fira Code'}, icon=None, favicon='assets/favicon.ico', logo='assets/logo.svg', palette=[{'scheme': 'glacier_light', 'toggle': {'icon': 'material/weather-night', 'name': 'Switch to dark mode'}}, {'scheme': 'glacier_dark', 'toggle': {'icon': 'material/weather-sunny', 'name': 'Switch to light mode'}}]), 'docs_dir': '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/docs', 'site_dir': '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/site', 'copyright': None, 'google_analytics': None, 'dev_addr': _IpAddressValue(host='127.0.0.1', port=8000), 'use_directory_urls': True, 'repo_url': 'https://github.com/jouvetg/igm', 'repo_name': 'jouvetg/igm', 'edit_uri_template': None, 'edit_uri': 'edit/master/docs/', 'extra_css': ['stylesheets/extra.css'], 'extra_javascript': ['javascripts/mathjax.js', 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML', 'https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js'], 'extra_templates': [], 'markdown_extensions': ['toc', 'tables', 'fenced_code', 'pymdownx.highlight', 'pymdownx.inlinehilite', 'pymdownx.snippets', 'pymdownx.superfences', 'admonition', 'pymdownx.details', 'pymdownx.arithmatex'], 'mdx_configs': {'pymdownx.highlight': {'anchor_linenums': True, 'line_spans': '__span', 'pygments_lang_class': True}, 'pymdownx.arithmatex': {'generic': True}}, 'strict': False, 'remote_branch': 'gh-pages', 'remote_name': 'origin', 'extra': {'version': {'provider': 'mike'}}, 'plugins': {'mike': , 'material/search': , 'include-markdown': , 'macros': , 'table-reader': }, 'hooks': {}, 'watch': [], 'validation': {'nav': {'omitted_files': 20, 'not_found': 30, 'absolute_links': 20}, 'links': {'not_found': 30, 'absolute_links': 20, 'unrecognized_links': 20, 'anchors': 20}}} environment dict system = 'Linux', system_version = '6.11.0-19-generic', python_version = '3.10.16', mkdocs_version = '1.6.1', macros_plugin_version = '1.3.7', jinja2_version = '3.1.6' plugin LegacyConfig {'module_name': 'main', 'modules': [], 'render_by_default': True, 'force_render_paths': '', 'include_dir': './igm/igm/', 'include_yaml': [], 'j2_block_start_string': '', 'j2_block_end_string': '', 'j2_variable_start_string': '', 'j2_variable_end_string': '', 'j2_comment_start_string': '', 'j2_comment_end_string': '', 'on_undefined': 'keep', 'on_error_fail': False, 'verbose': False} git dict status = True, date [datetime], short_commit = 'f7302d9', commit = 'f7302d97fc5b7c693ffdce1aea6caf893ace1f70', tag = '', short_tag = '', author = 'Guillaume Jouvet', author_email = 'guillaume.jouvet@gmail.com', committer = 'Guillaume Jouvet', committer_email = 'guillaume.jouvet@gmail.com', date_ISO = 'Thu Mar 27 07:20:01 2025 +0100', message = 'update user-module, and examples', raw = 'commit f7302d97fc5b7c693ffdce1aea6caf893ace1f70\\nAuthor: Guillaume Jouvet \\nDate:   Thu Mar 27 07:20:01 2025 +0100\\n\\n    update user-module, and examples', root_dir = '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc' version SuperDict provider = 'mike' macros SuperDict context [function], macros_info [function], now [function], fix_url [function], load_yaml [function], read_csv [ParseArgs], read_table [ParseArgs], read_fwf [ParseArgs], read_excel [ParseArgs], read_yaml [ParseArgs], read_json [ParseArgs], read_feather [ParseArgs], read_raw [ParseArgs], pd_read_csv [ParseArgs], pd_read_table [ParseArgs], pd_read_fwf [ParseArgs], pd_read_excel [ParseArgs], pd_read_yaml [ParseArgs], pd_read_json [ParseArgs], pd_read_feather [ParseArgs] filters dict pretty [function], relative_url [function], add_indentation [function], convert_to_md_table [function] filters_builtin dict abs [builtin_function_or_method], attr [function], batch [function], capitalize [function], center [function], count [builtin_function_or_method], d [function], default [function], dictsort [function], e [function], escape [function], filesizeformat [function], first [function], float [function], forceescape [function], format [function], groupby [function], indent [function], int [function], join [function], last [function], length [builtin_function_or_method], list [function], lower [function], items [function], map [function], min [function], max [function], pprint [function], random [function], reject [function], rejectattr [function], replace [function], reverse [function], round [function], safe [function], select [function], selectattr [function], slice [function], sort [function], string [function], striptags [function], sum [function], title [function], trim [function], truncate [function], unique [function], upper [function], urlencode [function], urlize [function], wordcount [function], wordwrap [function], xmlattr [function], tojson [function] navigation Navigation files Files page Page Page(title='Quick demo', url='/igm-doc.github.io/2.2.3/examples/quick_demo/')"},{"location":"examples/quick_demo/#config-information","title":"Config Information","text":"<p>Standard MkDocs configuration information. Do not try to modify.</p> <p>e.g. <code>{{ config.docs_dir }}</code></p> <p>See also the MkDocs documentation on the config object.</p> Variable Type Content config_file_path str '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/mike-mkdocssklj6t6k.yml' site_name str 'Instructed Glacier Model (IGM)' nav list [{'Home': 'index.md'}, {'Installation': [{'Quick Start': 'installation/quick_start.md'}, {'Other': [{'Nvidia Drivers': 'installation/other/nvidia_drivers.md'}, {'Virtual Environments': 'installation/other/virtual_environment.md'}, {'WSL Windows': 'installation/other/wsl_windows.md'}]}]}, {'Getting Started': [{'Using Hydra': [{'Introduction': 'hydra/introduction.md'}, {'Configuration': 'hydra/configuration.md'}, {'Distributed Computing': 'hydra/distributed_computing.md'}]}, {'Examples': 'examples/Examples.md'}]}, {'Modules': [{'What are modules?': 'modules/introduction.md'}, {'Input': [{'local': 'modules/inputs/local.md'}, {'load_ncdf': 'modules/inputs/load_ncdf.md'}, {'load_tif': 'modules/inputs/load_tif.md'}, {'oggm_shop': 'modules/inputs/oggm_shop.md'}]}, {'Processes': [{'avalanche': 'modules/processes/avalanche.md'}, {'clim_glacialindex': 'modules/processes/clim_glacialindex.md'}, {'clim_oggm': 'modules/processes/clim_oggm.md'}, {'enthalpy': 'modules/processes/enthalpy.md'}, {'gflex': 'modules/processes/gflex.md'}, {'glerosion': 'modules/processes/glerosion.md'}, {'iceflow': 'modules/processes/iceflow.md'}, {'particles': 'modules/processes/particles.md'}, {'read_output': 'modules/processes/read_output.md'}, {'rockflow': 'modules/processes/rockflow.md'}, {'smb_accpdd': 'modules/processes/smb_accpdd.md'}, {'smb_oggm': 'modules/processes/smb_oggm.md'}, {'smb_simple': 'modules/processes/smb_simple.md'}, {'texture': 'modules/processes/texture.md'}, {'thk': 'modules/processes/thk.md'}, {'time': 'modules/processes/time.md'}, {'vert_flow': 'modules/processes/vert_flow.md'}]}, {'Output': [{'local': 'modules/outputs/local.md'}, {'write_ncdf': 'modules/outputs/write_ncdf.md'}, {'write_tif': 'modules/outputs/write_tif.md'}, {'write_ts': 'modules/outputs/write_ts.md'}, {'plot2d': 'modules/outputs/plot2d.md'}]}, {'User': 'about/user_modules.md'}]}, {'About': [{'Transitioning from IGM 2 to 3': 'about/transition-IGM-2-to-3.md'}, {'Graphical Processing Units (GPUs)': 'about/gpus.md'}, {'Tensorflow': 'about/tensorflow.md'}, {'Crediting IGM': 'about/credits_and_references.md'}, {'Variables': 'about/variables.md'}]}] pages NoneType None exclude_docs NoneType None draft_docs NoneType None not_in_nav NoneType None site_url str 'https://jouvetg.github.io/igm-doc.github.io/2.2.3' site_description str 'Run your own glacier simulations in a fast, accurate, and user-friendly way.' site_author NoneType None theme Theme Theme(name='material', dirs=['/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/docs/material/overrides', '/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/material/templates', '/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/mkdocs/templates'], static_templates={'404.html', 'sitemap.xml'}, name='material', locale=Locale('en'), language='en', direction=None, features=['content.code.copy', 'content.code.annotate', 'content.code.select', 'navigation.path', 'navigation.instant.progress', 'navigation.tabs', 'navigation.footer', 'toc.integrate', 'toc.follow', 'search.highlight', 'search.suggest'], font={'text': 'Inter', 'code': 'Fira Code'}, icon=None, favicon='assets/favicon.ico', logo='assets/logo.svg', palette=[{'scheme': 'glacier_light', 'toggle': {'icon': 'material/weather-night', 'name': 'Switch to dark mode'}}, {'scheme': 'glacier_dark', 'toggle': {'icon': 'material/weather-sunny', 'name': 'Switch to light mode'}}]) docs_dir str '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/docs' site_dir str '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/site' copyright NoneType None google_analytics NoneType None dev_addr _IpAddressValue _IpAddressValue(host='127.0.0.1', port=8000) use_directory_urls bool True repo_url str 'https://github.com/jouvetg/igm' repo_name str 'jouvetg/igm' edit_uri_template NoneType None edit_uri str 'edit/master/docs/' extra_css list ['stylesheets/extra.css'] extra_javascript list ['javascripts/mathjax.js', 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML', 'https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js'] extra_templates list [] markdown_extensions list ['toc', 'tables', 'fenced_code', 'pymdownx.highlight', 'pymdownx.inlinehilite', 'pymdownx.snippets', 'pymdownx.superfences', 'admonition', 'pymdownx.details', 'pymdownx.arithmatex'] mdx_configs dict pymdownx.highlight [dict], pymdownx.arithmatex [dict] strict bool False remote_branch str 'gh-pages' remote_name str 'origin' extra LegacyConfig {'version': {'provider': 'mike'}} plugins PluginCollection mike [MikePlugin], material/search [SearchPlugin], include-markdown [IncludeMarkdownPlugin], macros [MacrosPlugin], table-reader [TableReaderPlugin] hooks dict watch list [] validation Validation {'nav': {'omitted_files': 20, 'not_found': 30, 'absolute_links': 20}, 'links': {'not_found': 30, 'absolute_links': 20, 'unrecognized_links': 20, 'anchors': 20}}"},{"location":"examples/quick_demo/#macros","title":"Macros","text":"<p>These macros have been defined programmatically for this environment (module or pluglets). </p>"},{"location":"examples/quick_demo/#typeerror-isinstance-arg-2-must-be-a-type-a-tuple-of-types-or-a-union","title":"TypeError: isinstance() arg 2 must be a type, a tuple of types, or a union","text":"<p>Traceback (most recent call last):   File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/mkdocs_macros/context.py\", line 355, in pretty     rows = [(\"%s\" % var, \"%s\" % var_type,   File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/mkdocs_macros/context.py\", line 355, in      rows = [(\"%s\" % var, \"%s\" % var_type,   File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/super_collections/init.py\", line 168, in str     return self.to_hjson()   File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/super_collections/init.py\", line 162, in to_hjson     python_dict = json.loads(self.to_json())   File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/super_collections/init.py\", line 152, in to_json     return json.dumps(self, cls=CustomEncoder)   File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/json/init.py\", line 238, in dumps     **kw).encode(obj)   File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/json/encoder.py\", line 199, in encode     chunks = self.iterencode(o, _one_shot=True)   File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/json/encoder.py\", line 257, in iterencode     return _iterencode(o, 0)   File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/super_collections/init.py\", line 33, in default     if isinstance(obj, datetime): TypeError: isinstance() arg 2 must be a type, a tuple of types, or a union"},{"location":"examples/quick_demo/#git-information","title":"Git Information","text":"<p>Information available on the last commit and the git repository containing the documentation project:</p> <p>e.g. <code>{{ git.message }}</code></p> Variable Type Content status bool True date datetime datetime.datetime(2025, 3, 27, 7, 20, 1, tzinfo=tzoffset(None, 3600)) short_commit str 'f7302d9' commit str 'f7302d97fc5b7c693ffdce1aea6caf893ace1f70' tag str '' short_tag str '' author str 'Guillaume Jouvet' author_email str 'guillaume.jouvet@gmail.com' committer str 'Guillaume Jouvet' committer_email str 'guillaume.jouvet@gmail.com' date_ISO str 'Thu Mar 27 07:20:01 2025 +0100' message str 'update user-module, and examples' raw str 'commit f7302d97fc5b7c693ffdce1aea6caf893ace1f70\\nAuthor: Guillaume Jouvet \\nDate:   Thu Mar 27 07:20:01 2025 +0100\\n\\n    update user-module, and examples' root_dir str '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc'"},{"location":"examples/quick_demo/#page-attributes","title":"Page Attributes","text":"<p>Provided by MkDocs. These attributes change for every page (the attributes shown are for this page).</p> <p>e.g. <code>{{ page.title }}</code></p> <p>See also the MkDocs documentation on the page object.</p> Variable Type Content file File src_uri = 'examples/quick_demo.md', src_dir = '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/docs', dest_dir = '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/site', use_directory_urls = True, inclusion [InclusionLevel], name = 'quick_demo', dest_uri = 'examples/quick_demo/index.html', page [Page], url = 'examples/quick_demo/', abs_src_path = '/media/gjouvet/storage/Dropbox/home/IGM/igm-doc/docs/examples/quick_demo.md' children NoneType None previous_page NoneType None next_page NoneType None _Page__active bool False update_date str '2025-03-28' canonical_url str 'https://jouvetg.github.io/igm-doc.github.io/2.2.3/examples/quick_demo/' abs_url str '/igm-doc.github.io/2.2.3/examples/quick_demo/' edit_url str 'https://github.com/jouvetg/igm/edit/master/docs/examples/quick_demo.md' markdown str '{{ macros_info() }}\\n' _title_from_render NoneType None content NoneType None toc list [] meta dict <p>To have all titles of all pages, use:</p> <pre><code>{% for page in navigation.pages %}\n- {{ page.title }}\n{% endfor %}\n</code></pre>"},{"location":"examples/quick_demo/#plugin-filters","title":"Plugin Filters","text":"<p>These filters are provided as a standard by the macros plugin.</p> Variable Type Content pretty function (var_list, rows, header, e) <p>Default Mkdocs-Macro: Prettify a dictionary or object          (used for environment documentation, or debugging).</p> relative_url function (path) <p>Default Mkdocs-Macro:         convert the path of any page according to MkDoc's internal logic,         into a URL relative to the current page         (implements the <code>normalize_url()</code> function from <code>mkdocs.util</code>).         Typically used to manage custom navigation:         <code>{{ page.url | relative_url }}</code>.</p> add_indentation function (text, spaces, tabs, indentation, fixed_lines, line) <p>Adds indentation to a text.</p> convert_to_md_table function (df, markdown_kwargs) <p>Convert dataframe to markdown table using tabulate.</p>"},{"location":"examples/quick_demo/#builtin-jinja2-filters","title":"Builtin Jinja2 Filters","text":"<p>These filters are provided by Jinja2 as a standard.</p> <p>See also the Jinja2 documentation on builtin filters.</p> Variable Type Content abs builtin_function_or_method <p>Return the absolute value of the argument.</p> attr function (environment, obj, name) <p>Get an attribute of an object. <code>foo|attr(\"bar\")</code> works like     <code>foo.bar</code>, but returns undefined instead of falling back to <code>foo[\"bar\"]</code>     if the attribute doesn't exist.</p> batch function (value, linecount, fill_with, tmp, item) <p>A filter that batches items. It works pretty much like <code>slice</code>     just the other way round. It returns a list of lists with the     given number of items. If you provide a second parameter this     is used to fill up missing items. See this example.</p> capitalize function (s) <p>Capitalize a value. The first character will be uppercase, all others     lowercase.</p> center function (value, width) <p>Centers the value in a field of a given width.</p> count builtin_function_or_method <p>Return the number of items in a container.</p> d function (value, default_value, boolean) <p>If the value is undefined it will return the passed default value,     otherwise the value of the variable.</p> default function (value, default_value, boolean) <p>If the value is undefined it will return the passed default value,     otherwise the value of the variable.</p> dictsort function (value, case_sensitive, by, reverse, sort_func) <p>Sort a dict and yield (key, value) pairs. Python dicts may not     be in the order you want to display them in, so sort them first.</p> e function (s) <p>Replace the characters <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>'</code>, and <code>\"</code> in     the string with HTML-safe sequences. Use this if you need to display     text that might contain such characters in HTML.</p> escape function (s) <p>Replace the characters <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>'</code>, and <code>\"</code> in     the string with HTML-safe sequences. Use this if you need to display     text that might contain such characters in HTML.</p> filesizeformat function (value, binary, bytes, base, prefixes, i, prefix, unit) <p>Format the value like a 'human-readable' file size (i.e. 13 kB,     4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega,     Giga, etc.), if the second parameter is set to <code>True</code> the binary     prefixes are used (Mebi, Gibi).</p> first function (args, kwargs, b) <p>Return the first item of a sequence.</p> float function (value, default) <p>Convert the value into a floating point number. If the     conversion doesn't work it will return <code>0.0</code>. You can     override this default using the first parameter.</p> forceescape function (value) <p>Enforce HTML escaping.  This will probably double escape variables.</p> format function (value, args, kwargs) <p>Apply the given values to a <code>printf-style</code>_ format string, like     <code>string % values</code>.</p> groupby function (args, kwargs, b) <p>Group a sequence of objects by an attribute using Python's     :func:<code>itertools.groupby</code>. The attribute can use dot notation for     nested access, like <code>\"address.city\"</code>. Unlike Python's <code>groupby</code>,     the values are sorted first so only one group is returned for each     unique value.</p> indent function (s, width, first, blank, newline, rv, lines) <p>Return a copy of the string with each line indented by 4 spaces. The     first line and blank lines are not indented by default.</p> int function (value, default, base) <p>Convert the value into an integer. If the     conversion doesn't work it will return <code>0</code>. You can     override this default using the first parameter. You     can also override the default base (10) in the second     parameter, which handles input with prefixes such as     0b, 0o and 0x for bases 2, 8 and 16 respectively.     The base is ignored for decimal numbers and non-string values.</p> join function (args, kwargs, b) <p>Return a string which is the concatenation of the strings in the     sequence. The separator between elements is an empty string per     default, you can define it with the optional parameter.</p> last function (environment, seq) <p>Return the last item of a sequence.</p> length builtin_function_or_method <p>Return the number of items in a container.</p> list function (args, kwargs, b) <p>Convert the value into a list.  If it was a string the returned list     will be a list of characters.</p> lower function (s) <p>Convert a value to lowercase.</p> items function (value) <p>Return an iterator over the <code>(key, value)</code> items of a mapping.</p> map function (args, kwargs, b) <p>Applies a filter on a sequence of objects or looks up an attribute.     This is useful when dealing with lists of objects but you are really     only interested in a certain value of it.</p> min function (environment, value, case_sensitive, attribute) <p>Return the smallest item from the sequence.</p> max function (environment, value, case_sensitive, attribute) <p>Return the largest item from the sequence.</p> pprint function (value) <p>Pretty print a variable. Useful for debugging.</p> random function (context, seq) <p>Return a random item from the sequence.</p> reject function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to each object,     and rejecting the objects with the test succeeding.</p> rejectattr function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to the specified     attribute of each object, and rejecting the objects with the test     succeeding.</p> replace function (eval_ctx, s, old, new, count) <p>Return a copy of the value with all occurrences of a substring     replaced with a new one. The first argument is the substring     that should be replaced, the second is the replacement string.     If the optional third argument <code>count</code> is given, only the first     <code>count</code> occurrences are replaced.</p> reverse function (value, rv, e) <p>Reverse the object or return an iterator that iterates over it the other     way round.</p> round function (value, precision, method, func) <p>Round the number to a given precision. The first     parameter specifies the precision (default is <code>0</code>), the     second the rounding method.</p> safe function (value) <p>Mark the value as safe which means that in an environment with automatic     escaping enabled this variable will not be escaped.</p> select function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to each object,     and only selecting the objects with the test succeeding.</p> selectattr function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to the specified     attribute of each object, and only selecting the objects with the     test succeeding.</p> slice function (args, kwargs, b) <p>Slice an iterator and return a list of lists containing     those items. Useful if you want to create a div containing     three ul tags that represent columns.</p> sort function (environment, value, reverse, case_sensitive, attribute, key_func) <p>Sort an iterable using Python's :func:<code>sorted</code>.</p> string function (s) <p>Convert an object to a string if it isn't already. This preserves     a :class:<code>Markup</code> string rather than converting it back to a basic     string, so it will still be marked as safe and won't be escaped     again.</p> striptags function (value) <p>Strip SGML/XML tags and replace adjacent whitespace by one space.</p> sum function (args, kwargs, b) <p>Returns the sum of a sequence of numbers plus the value of parameter     'start' (which defaults to 0).  When the sequence is empty it returns     start.</p> title function (s) <p>Return a titlecased version of the value. I.e. words will start with     uppercase letters, all remaining characters are lowercase.</p> trim function (value, chars) <p>Strip leading and trailing characters, by default whitespace.</p> truncate function (env, s, length, killwords, end, leeway, result) <p>Return a truncated copy of the string. The length is specified     with the first parameter which defaults to <code>255</code>. If the second     parameter is <code>true</code> the filter will cut the text at length. Otherwise     it will discard the last word. If the text was in fact     truncated it will append an ellipsis sign (<code>\"...\"</code>). If you want a     different ellipsis sign than <code>\"...\"</code> you can specify it using the     third parameter. Strings that only exceed the length by the tolerance     margin given in the fourth parameter will not be truncated.</p> unique function (args, kwargs, b) <p>Returns a list of unique items from the given iterable.</p> upper function (s) <p>Convert a value to uppercase.</p> urlencode function (value, items) <p>Quote data for use in a URL path or query using UTF-8.</p> urlize function (eval_ctx, value, trim_url_limit, nofollow, target, rel, extra_schemes, policies, rel_parts, scheme, rv) <p>Convert URLs in text into clickable links.</p> wordcount function (s) <p>Count the words in that string.</p> wordwrap function (environment, s, width, break_long_words, wrapstring, break_on_hyphens) <p>Wrap a string to the given width. Existing newlines are treated     as paragraphs to be wrapped separately.</p> xmlattr function (eval_ctx, d, autospace, items, key, value, rv) <p>Create an SGML/XML attribute string based on the items in a dict.</p> tojson function (eval_ctx, value, indent, policies, dumps, kwargs) <p>Serialize an object to a string of JSON, and mark it safe to     render in HTML. This filter is only for use in HTML documents.</p>"},{"location":"hydra/configuration/","title":"Hi config","text":""},{"location":"hydra/distributed_computing/","title":"Hi computing","text":""},{"location":"hydra/introduction/","title":"Hi intro","text":""},{"location":"installation/linux/","title":"Linux","text":"<ol> <li>Install NVIDIA drivers</li> </ol> <p>If you aim to use only the CPU or already get an output from <code>nvidia-smi</code>, you can skip this step.</p> <p><pre><code># get the latest libraries from apt\nsudo apt update\nsudo apt upgrade\n\n# choose which driver version is compatible with your GPU device (in this case 510)\nsudo apt install nvidia-driver-510 nvidia-dkms-510\nsudo reboot # you wont see the changes until after you reboot\n</code></pre> After rebooting, you can check your driver version with the command <code>watch -d -n 0.5 nvidia-smi</code> should give you live information on your GPU device.</p> <ol> <li>Install anaconda and create a virtual environment (strongly recommended) with conda or venv:</li> </ol> <pre><code># install anaconda\nwget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh\nbash Anaconda3-2023.09-0-Linux-x86_64.sh\n\n# create new environment\nconda create --name igm python=3.10\n\n# activate environment to install IGM\nconda activate igm\n</code></pre> <p>or</p> <pre><code># create igm venv environment\npython3.10 -m venv igm\n\n# activate environment to install IGM\nsource igm/bin/activate\n</code></pre> <ol> <li>Install IGM</li> </ol> <p>For simple usage, you can install the latest IGM stable version and its dependencies from the Pypi as follows:</p> <pre><code>pip install igm_model\n</code></pre> <p>OR for using all and recent features, you can install the IGM development version from the github repository as follows:</p> <pre><code>git clone https://github.com/jouvetg/igm.git\ncd igm\npip install -e .\n</code></pre> <p>After that, you may run any example (<code>igm_run</code>). As IGM is being updated often, make sure you have the latest version, you may run</p> <pre><code>git pull\n</code></pre>"},{"location":"installation/mac/","title":"Mac","text":"<p>IGM core library native Tensorflow is not supported on Mac for GPU usage. Instead, a \"Tensorflow for Mac\", called tensorflow-metal, was developed as workaround. To install IGM on Mac, you may follow the linux workflow, however, you will need to change in setup.py tensorflow by tensorflow-macos. Here is a working procedure (tested on MacBook Pro M2) -- still we recommend using a virtual environment such as conda or venv as on linux:</p> <p><pre><code>git clone -b develop https://github.com/jouvetg/igm\ncd igm\n</code></pre> You need to edit \"install_requires=[...]\" in the file \"setup.py\":</p> <ul> <li>To use only the CPUs: <code>tensorflow-macos==2.14.0</code></li> <li>To use the GPUs: <code>tensorflow-macos==2.14.0, tensorflow-metal,</code></li> </ul> <p>and then <pre><code>pip install -e .\n</code></pre></p>"},{"location":"installation/quick_start/","title":"Quick Start","text":"<p>This guide serves as the fastest way to install IGM. It assumes that have already</p> <ol> <li>Downloaded the nvidia drivers</li> <li>Have a working virtual environment</li> </ol> <p>If this is the case, you can skip to the next section.</p> <p>Note</p> <p>Tensorflow does not allow us to run IGM on GPU directly on Windows, and the module <code>oggm_shop</code> does not work on windows. Therefore, we recommend windows-user to install WSL2-ubuntu, which provides a linux/ubuntu terminal. WSL2 terminal can be nicely linked with VS code (with an extension). First, install WSL2-ubuntu</p> <pre><code>wsl --install Ubuntu-22.04\nsudo apt update\nsudo apt upgrade\n</code></pre>"},{"location":"installation/quick_start/#installing-methods","title":"Installing Methods","text":"<p>Once this is done, the options are the following</p> <ol> <li>pip</li> <li>github</li> <li>docker</li> </ol>"},{"location":"installation/quick_start/#pip","title":"Pip","text":"<p>To install the latest version of IGM, simply run</p> <pre><code>pip install igm_model\n</code></pre> <p>For reproducibility purposes, one might want to install a specific version of IGM. In order to do this, one can specify the version (note, this version must exist on the PyPI servers).</p> <pre><code>pip install igm_model=='2.2.2'\n</code></pre>"},{"location":"installation/quick_start/#github","title":"Github","text":"<p>If one wants to have the latest versions, or even, work on a specific hash for reproducibility, one can download IGM through the github repository. This is useful for developers, and researchers alike, who want to have the latest features as well as contribute to IGM's model personally.</p> <p>One can download the latest version of IGM with <code>git clone</code></p> <pre><code>git clone https://github.com/jouvetg/igm.git\n</code></pre> <p>Note</p> <p>IGM core library native Tensorflow is not supported on Mac for GPU usage. Instead, a \"Tensorflow for Mac\", called tensorflow-metal, was developed as workaround. To install IGM on Mac, you may follow the linux workflow, however, you will need to change in setup.py tensorflow by tensorflow-macos. Here is a working procedure (tested on MacBook Pro M2) -- still we recommend using a virtual environment such as conda or venv as on linux:</p> <p><pre><code>git clone -b develop https://github.com/jouvetg/igm\ncd igm\n</code></pre> You need to edit \"install_requires=[...]\" in the file \"setup.py\":</p> <ul> <li>To use only the CPUs: <code>tensorflow-macos==2.14.0</code></li> <li>To use the GPUs: <code>tensorflow-macos==2.14.0, tensorflow-metal,</code></li> </ul> <pre><code>cd igm\npip install -e .\n</code></pre> <p>After that, you may run any example (<code>igm_run</code>). As IGM is being updated often, make sure you have the latest version, you may run</p> <pre><code>git pull\n</code></pre>"},{"location":"installation/quick_start/#docker","title":"Docker","text":"<p>For even more granular control, one can opt to use the docker image instead of the github version. This maximizes the chances of reproducibility stability as the virtual environmnet is part of the installation of IGM. ... Assuming you have docker installed already, you can download the docker image through two ways</p> <ol> <li>Docker CLI</li> <li>DockerHub</li> </ol> <p>In order to download IGM through the commandline, you can run the following command</p> <pre><code>docker ...\n</code></pre>"},{"location":"installation/windows/","title":"Windows","text":"<p>Tensorflow does not allow us to run IGM on GPU directly on Windows, and the module <code>oggm_shop</code> does not work on windows. Therefore, we recommend windows-user to install WSL2-ubuntu, which provides a linux/ubuntu terminal. WSL2 terminal can be nicely linked with VS code (with an extension). First, install WSL2-ubuntu</p> <pre><code>wsl --install Ubuntu-22.04\nsudo apt update\nsudo apt upgrade\n</code></pre> <p>and then, install the NVIDIA drivers if not done (if you get no output from <code>nvidia-smi</code>), and if you wish to use the GPU.</p> <p>The rest -- installation of conda or venv environment and the installation of IGM -- are the same as above on Linux.</p>"},{"location":"installation/other/nvidia_drivers/","title":"Nvidia Drivers","text":"<p>If you aim to use only the CPU or already get an output from <code>nvidia-smi</code>, you can skip this step.</p> <p>! Give instructions for the driver version depending on the Tensorflow / GPU version</p> <p><pre><code># get the latest libraries from apt\nsudo apt update\nsudo apt upgrade\n\n# choose which driver version is compatible with your GPU device (in this case 510)\nsudo apt install nvidia-driver-510 nvidia-dkms-510\nsudo reboot # you wont see the changes until after you reboot\n</code></pre> After rebooting, you can check your driver version with the command <code>watch -d -n 0.5 nvidia-smi</code> should give you live information on your GPU device.</p> <p>! Give Photo</p>"},{"location":"installation/other/virtual_environment/","title":"Virtual Environments","text":"<p>Install anaconda and create a virtual environment (strongly recommended) with conda or venv:</p> <pre><code># install anaconda\nwget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh\nbash Anaconda3-2023.09-0-Linux-x86_64.sh\n\n# create new environment\nconda create --name igm python=3.10\n\n# activate environment to install IGM\nconda activate igm\n</code></pre> <p>or one can install a virtual environment without needing to use conda by using the <code>venv</code> module that is built-in to <code>python</code></p> <pre><code># create igm venv environment\npython3.10 -m venv igm\n\n# activate environment to install IGM\nsource igm/bin/activate\n</code></pre>"},{"location":"installation/other/wsl_windows/","title":"WSL Windows","text":"<pre><code>wsl --install Ubuntu-22.04\nsudo apt update\nsudo apt upgrade\n</code></pre> <p>and then, install the NVIDIA drivers if not done (if you get no output from <code>nvidia-smi</code>), and if you wish to use the GPU.</p> <p>The rest -- installation of conda or venv environment and the installation of IGM -- are the same as above on Linux.</p>"},{"location":"modules/introduction/","title":"Introduction","text":"<p>IGM is organized in a module-wise fashion, recognizing the similarity in the tasks performed such as the loading of data, the initializing of fields, the update of these fields within a time loop, or the outputting results at regular time intervals. Each module handles a specific aspect of the glacier evolution process, making the model modular:</p> <ul> <li> <p>the <code>inputs</code> modules serve to load data (e.g., glacier bedrock, ice surface velocities, ...),</p> </li> <li> <p>the <code>processes</code> modules implement physical mechanisms in a decoupled manner (e.g., ice flow, mass conservation, ...),</p> </li> <li> <p>the <code>outputs</code> modules serve to write or plot model results.</p> </li> </ul> <p>The main Python script <code>igm_run</code> permits to load all <code>inputs</code>, <code>processes</code>, <code>outputs</code> modules and their parameters, initialize, update them within a time loop, and finalize them. The large majority of the IGM code is part of modules, while the core structure is very lightweight. Each module includes:</p> <ul> <li> <p>a name that is used to identify it (e.g., <code>greatmodule</code>)</p> </li> <li> <p>a source code located <code>XXX/greatmodule/greatmodule.py</code> where XXX is folder <code>inputs</code>, <code>processes</code>, or <code>outputs</code> according to the nature of the module.</p> </li> <li> <p>a parameter file located in <code>conf/XXX/greatmodule.yaml</code> with default parameters,</p> </li> <li> <p>a help file <code>conf_help/XXX/greatmodule.yaml</code> specifying the definition of each parameter, its type and unit.</p> </li> <li> <p>a documentation page located on the <code>igm-doc</code> GitHub repo that serves to build the documentation.</p> </li> </ul> <p>For convenience, users can write their own module-parameter pair in a folder <code>user</code>, and can call the user module from the parameter file.</p>"},{"location":"modules/inputs/load_ncdf/","title":"Module <code>load_ncdf</code>","text":"<p>Warning: we advise to use instead module <code>local</code></p> <p>This IGM module is designed to load spatial 2D raster data from a NetCDF file specified by the <code>input_file</code> parameter. The module converts all existing 2D fields into TensorFlow variables. At a minimum, the module is expected to import basal topography represented by the <code>topg</code> variable. Additionally, it completes the data, such as deriving basal topography from ice thickness and surface topography. Other fields present in the NetCDF file will also be converted to TensorFlow variables, allowing them to be accessed in the code via <code>state.myvar</code>. For example, providing the <code>icemask</code> variable can be useful in defining an accumulation area, which is beneficial for modeling individual glaciers and preventing overflow into neighboring catchments.</p> <p>The module offers functions for resampling the data, where the <code>coarsen</code> parameter can be set to values like 2, 3, or 4 (with a default value of 1 indicating no coarsening), and for cropping the data, which requires setting the <code>crop</code> parameter to True and specifying the desired bounds.</p> <p>Additionally, by setting <code>icemask_invert</code> to True, an ice mask can be generated from an ESRI Shapefile specified by the <code>icemask_shapefile</code> parameter. This mask can identify areas that should contain glaciers or areas that should remain glacier-free, based on the <code>icemask_include</code> parameter.</p> <p>The module also supports restarting an IGM run using a NetCDF file produced from a previous IGM run. To achieve this, provide the output NetCDF file from the previous run as input to IGM. The module will seek data corresponding to the starting time defined by <code>processes.time.start</code> and initialize the simulation at that time.</p> <p>This module depends on <code>netCDF4</code>.</p> <p>Contributors: G. Jouvet, A. Henz (icemask add-on)</p>"},{"location":"modules/inputs/load_ncdf/#config-structure","title":"Config Structure","text":"<pre><code>load_ncdf:\n  input_file: input.nc\n  method_coarsen: skipping\n  coarsen: 1\n  crop: False\n  xmin: -1.0e+20\n  xmax: 1.0e+20\n  ymin: -1.0e+20\n  ymax: 1.0e+20\n  icemask_include: False\n  icemask_shapefile: icemask.shp\n  icemask_invert: False\n</code></pre>"},{"location":"modules/inputs/load_ncdf/#parameters","title":"Parameters","text":"Name Type Units Description Default Value input_file str ['dimensionless'] NetCDF input data file input.nc method_coarsen str ['dimensionless'] Method for coarsening the data from NetCDF file (skipping or cubic_spline) skipping coarsen int ['dimensionless'] Coarsen the data from NetCDF file by a certain (integer) number (2 would be twice coarser ignore data each 2 grid points) 1 crop bool ['dimensionless'] Crop the data from NetCDF file with given top/down/left/right bounds False xmin float $m$ X left coordinate for cropping the NetCDF data -1e+20 xmax m float X right coordinate for cropping the NetCDF data 1e+20 ymin float $m$ Y bottom coordinate for cropping the NetCDF data -1e+20 ymax float $m$ Y top coordinate for cropping the NetCDF data 1e+20 icemask_include bool ['dimensionless'] Include ice mask in the NetCDF file False icemask_shapefile str ['dimensionless'] Shapefile for ice mask icemask.shp icemask_invert bool ['dimensionless'] Invert the ice mask False <p>--&gt;</p>"},{"location":"modules/inputs/load_ncdf/#example-usage","title":"Example Usage","text":""},{"location":"modules/inputs/load_tif/","title":"Module <code>load_tif</code>","text":"<p>Warning: we advise to use instead module <code>local</code></p> <p>This IGM module is designed to load spatial 2D raster data from any tif file present in the working directory <code>folder</code>, and transform each of them into tensorflow variables, the name of the file becoming the name of the variable, e.g. the file topg.tif will yield variable topg, ect... At a minimum, the module is expected to import basal topography represented by the <code>topg</code> variable. Additionally, it completes the data, such as deriving basal topography from ice thickness and surface topography. Other fields present in the folder file will also be converted to TensorFlow variables, allowing them to be accessed in the code via <code>state.myvar</code>. For example, providing the <code>icemask</code> variable can be useful in defining an accumulation area, which is beneficial for modeling individual glaciers and preventing overflow into neighboring catchments.</p> <p>The module offers functions for resampling the data, where the <code>coarsen</code> parameter can be set to values like 2, 3, or 4 (with a default value of 1 indicating no coarsening), and for cropping the data, which requires setting the <code>crop</code> parameter to True and specifying the desired bounds.</p> <p>Additionally, by setting <code>icemask_invert</code> to True, an ice mask can be generated from an ESRI Shapefile specified by the <code>icemask_shapefile</code> parameter. This mask can identify areas that should contain glaciers or areas that should remain glacier-free, based on the <code>icemask_include</code> parameter.</p> <p>This module depends on <code>rasterio</code>.</p> <p>Contributors: G. Jouvet, A. Henz (icemask add-on)</p>"},{"location":"modules/inputs/load_tif/#config-structure","title":"Config Structure","text":"<pre><code>load_tif:\n  folder: \"\"\n  coarsen: 1\n  crop: False\n  xmin: -1.0e+20\n  xmax: 1.0e+20\n  ymin: -1.0e+20\n  ymax: 1.0e+20\n  icemask_include: False\n  icemask_shapefile: icemask.shp\n  icemask_invert: False\n</code></pre>"},{"location":"modules/inputs/load_tif/#parameters","title":"Parameters","text":"Name Type Units Description Default Value folder str ['dimensionless'] Folder containing the tif files coarsen int ['dimensionless'] Coarsen the data from NetCDF file by a certain (integer) number (2 would be twice coarser ignore data each 2 grid points) 1 crop bool ['dimensionless'] Crop the data from NetCDF file with given top/down/left/right bounds False xmin float $m$ Crop the data from NetCDF file with the given minimum x bound -1e+20 xmax m float Crop the data from NetCDF file with the given maximum x bound 1e+20 ymin float $m$ Crop the data from NetCDF file with the given minimum y bound -1e+20 ymax float $m$ Crop the data from NetCDF file with the given maximum y bound 1e+20 icemask_include bool ['dimensionless'] Include ice mask in the NetCDF file False icemask_shapefile str ['dimensionless'] Shapefile for ice mask icemask.shp icemask_invert bool ['dimensionless'] Invert the ice mask False"},{"location":"modules/inputs/load_tif/#example-usage","title":"Example Usage","text":""},{"location":"modules/inputs/local/","title":"Macro Rendering Error","text":"<p>File: <code>modules/inputs/local.md</code></p> <p>UndefinedError: 'dict object' has no attribute 'coarsening'</p> <pre><code>Traceback (most recent call last):\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/mkdocs_macros/plugin.py\", line 688, in render\n    return md_template.render(**page_variables)\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 58, in top-level template code\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/jinja2/environment.py\", line 490, in getattr\n    return getattr(obj, attribute)\njinja2.exceptions.UndefinedError: 'dict object' has no attribute 'coarsening'\n</code></pre>"},{"location":"modules/inputs/oggm_shop/","title":"Macro Rendering Error","text":"<p>File: <code>modules/inputs/oggm_shop.md</code></p> <p>UndefinedError: 'dict object' has no attribute 'highres'</p> <pre><code>Traceback (most recent call last):\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/mkdocs_macros/plugin.py\", line 688, in render\n    return md_template.render(**page_variables)\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 74, in top-level template code\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/jinja2/environment.py\", line 490, in getattr\n    return getattr(obj, attribute)\njinja2.exceptions.UndefinedError: 'dict object' has no attribute 'highres'\n</code></pre>"},{"location":"modules/outputs/local/","title":"Module <code>local</code>","text":"<p>This IGM module writes 2D field variables defined in the paramer list <code>vars_to_save</code> into the NetCDF output file given by parameter <code>output_file</code> (default output.nc). The saving frequency is given by parameter <code>processes.time.save</code> defined in module <code>time</code>.</p> <p>This module depends on <code>xarray</code>.</p>"},{"location":"modules/outputs/local/#config-structure","title":"Config Structure","text":"<pre><code>local:\n  output_file: output.nc\n  vars_to_save:\n    - topg\n    - usurf\n    - thk\n    - smb\n    - velbar_mag\n    - velsurf_mag\n    - uvelsurf\n    - vvelsurf\n    - wvelsurf\n</code></pre>"},{"location":"modules/outputs/local/#parameters","title":"Parameters","text":"Name Type Units Description Default Value output_file str ['dimensionless'] Output ncdf data file output.nc vars_to_save list ['dimensionless'] List of variables to be recorded in the ncdf file ['topg', 'usurf', 'thk', 'smb', 'velbar_mag', 'velsurf_mag', 'uvelsurf', 'vvelsurf', 'wvelsurf']"},{"location":"modules/outputs/local/#example-usage","title":"Example Usage","text":""},{"location":"modules/outputs/plot2d/","title":"Module <code>plot2d</code>","text":"<p>This IGM module produces 2D plan-view plots of variable defined by parameter <code>var</code> (e.g. <code>var</code> can be set to <code>thk</code>, or <code>ubar</code>, ...). The saving frequency is given by parameter <code>processes.time.save</code> defined in module <code>time</code>.  The scale range of the colobar is controlled by parameter <code>varmax</code>.</p> <p>By default, the plots are saved as png files in the working directory. However, one may display the plot \"in live\" by setting <code>live</code> to True. Note that if you use the spyder python editor, you need to turn <code>editor</code> to 'sp'.</p> <p>If the <code>particles</code> module is activated, one may plot particles on the top setting <code>particles</code> to True, or remove them form the plot seeting it to False.</p>"},{"location":"modules/outputs/plot2d/#config-structure","title":"Config Structure","text":"<pre><code>plot2d:\n  editor: vs\n  live: False\n  particles: True\n  var: \"velbar_mag\"\n  var_max: 1000\n</code></pre>"},{"location":"modules/outputs/plot2d/#parameters","title":"Parameters","text":"Name Type Units Description Default Value editor str ['dimensionless'] Optimized for VS code (vs) or spyder (sp) for live plot vs live bool ['dimensionless'] Display plots live the results during computation instead of making png False particles bool ['dimensionless'] Display particles is True, does not display if False True var str ['dimensionless'] Name of the variable to plot velbar_mag var_max float ['variable'] Maximum value of the varplot variable used to adjust the scaling of the colorbar 1000"},{"location":"modules/outputs/plot2d/#example-usage","title":"Example Usage","text":""},{"location":"modules/outputs/write_ncdf/","title":"Module <code>write_ncdf</code>","text":"<p>This IGM module writes 2D field variables defined in the paramer list <code>vars_to_save</code> into the NetCDF output file given by parameter <code>output_file</code> (default output.nc). The saving frequency is given by parameter <code>processes.time.save</code> defined in module <code>time</code>.</p> <p>This module depends on <code>netCDF4</code>.</p>"},{"location":"modules/outputs/write_ncdf/#config-structure","title":"Config Structure","text":"<pre><code>write_ncdf:\n  output_file: output.nc\n  vars_to_save:\n    - topg\n    - usurf\n    - thk\n    - smb\n    - velbar_mag\n    - velsurf_mag\n    - uvelsurf\n    - vvelsurf\n    - wvelsurf\n</code></pre>"},{"location":"modules/outputs/write_ncdf/#parameters","title":"Parameters","text":"Name Type Units Description Default Value output_file str ['dimensionless'] Output ncdf data file output.nc vars_to_save list ['dimensionless'] List of variables to be recorded in the ncdf file ['topg', 'usurf', 'thk', 'smb', 'velbar_mag', 'velsurf_mag', 'uvelsurf', 'vvelsurf', 'wvelsurf']"},{"location":"modules/outputs/write_ncdf/#example-usage","title":"Example Usage","text":""},{"location":"modules/outputs/write_tif/","title":"Module <code>write_tif</code>","text":"<p>This IGM module writes 2D field variables defined in the paramer list <code>vars_to_save</code> into tif output files. Files will be created with names composed by the variable name and the time (e.g., thk-000040.tif, usurf-000090.tif) in the working directory. The saving frequency is given by parameter <code>processes.time.save</code> defined in module <code>time</code>. If input file were call with module <code>load_tif</code>, then the tif meta information are saved, and provided with the final tiff files.</p> <p>This module depends on the <code>rasterio</code> library.</p>"},{"location":"modules/outputs/write_tif/#config-structure","title":"Config Structure","text":"<pre><code>write_tif:\n  vars_to_save:\n      - usurf\n      - thk\n</code></pre>"},{"location":"modules/outputs/write_tif/#parameters","title":"Parameters","text":"Name Type Units Description Default Value vars_to_save list ['dimensionless'] List of variables to be saved as geotiff files ['usurf', 'thk']"},{"location":"modules/outputs/write_tif/#example-usage","title":"Example Usage","text":""},{"location":"modules/outputs/write_ts/","title":"Module <code>write_ts</code>","text":"<p>This IGM module writes time serie variables (ice glaciated area and volume) into the NetCDF output file defined by parameter <code>output_file</code> (default output_ts.nc). The saving frequency is given by parameter <code>processes.time.save</code> defined in module <code>time</code>.</p>"},{"location":"modules/outputs/write_ts/#config-structure","title":"Config Structure","text":"<pre><code>write_ts:\n  output_file: output_ts.nc\n</code></pre>"},{"location":"modules/outputs/write_ts/#parameters","title":"Parameters","text":"Name Type Units Description Default Value output_file str ['dimensionless'] Output ncdf data file (time series) output_ts.nc"},{"location":"modules/outputs/write_ts/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/avalanche/","title":"Module <code>avalanche</code>","text":"<p>This IGM module simulates the redistribution of snow and ice due to gravitational avalanches. The model assumes that if the local surface slope exceeds a given threshold (angle of repose), mass is redistributed toward lower elevations until the surface slope is reduced below this threshold.</p> <p>Contributors: J\u00fcrgen Mey, Guillaume Jouvet</p> <p>This function was adapted from Mark Kessler's GC2D program and implemented in IGM by J\u00fcrgen Mey with support from Guillaume Jouvet.</p>"},{"location":"modules/processes/avalanche/#config-structure","title":"Config Structure","text":"<pre><code>avalanche:\n  update_freq: 1\n  angleOfRepose: 30.0\n</code></pre>"},{"location":"modules/processes/avalanche/#parameters","title":"Parameters","text":"Name Type Units Description Default Value update_freq float $y$ Frequency at which to update the avalanche module 1 angleOfRepose float Degrees Angle of repose (threshold for avalanche initiation) 30.0"},{"location":"modules/processes/avalanche/#example-usage","title":"Example Usage","text":"<p>We can run a simulation with a higher frequency of avalanches by changing the <code>processes.avalanche.update_freq</code> argument. We can either do this in our config file.</p> <pre><code># @package _global_\n\ncore:\n  url_data: https://www.dropbox.com/scl/fo/kd7dix5j1tm75nj941pvi/h?rlkey=q7jtmf9yn3a970cqygdwne25j&amp;dl=0\n\ninputs:\n  load_ncdf:\n    input_file: data/input.nc\n\nprocesses:\n  smb_simple:\n    array:\n      - [\"time\", \"gradabl\", \"gradacc\", \"ela\", \"accmax\"]\n      - [1900, 0.009, 0.005, 2800, 2.0]\n      - [2000, 0.009, 0.005, 2900, 2.0]\n      - [2100, 0.009, 0.005, 3300, 2.0]\n  time:\n    start: 1900.0\n    end: 2000.0\n    save: 10.0\n  avalanche:\n      update_freq: 5 # every 5 years\n</code></pre> <p>Alternatively, we can do it over the command line</p> <pre><code>igm_run +experiment/params processes.avalanche.update_freq=5\n</code></pre>"},{"location":"modules/processes/clim_glacialindex/","title":"Module <code>clim_glacialindex</code>","text":"<p>Module <code>clim_glacialindex</code> loads two climate snapshots (associated to a certain periods) and interpolate them using a climate signal and a glacial index approach [1]. It is suitable for paleo glacier modelling.</p> <p>For that purpose, we define a function GI that maps time \\(t\\) to a scalar with two extreme states: one state \\({\\rm CL}_0\\) with nearly no ice corresponding to GI=\\(0\\) and one maximum state \\({\\rm CL}_1\\) in terms of glacier extent corresponding GI=\\(1\\). The Climate CL consists of a set of variables:  mean temperature, temperature variability, mean precipitation, and lapse rate, $$ \\begin{align} {\\rm CL}(t) =(T^{\\rm mean}(t),T^{\\rm std}(t),P^{\\rm mean}(t), {\\rm LR}(t)), \\end{align}  $$ and is assumed to be a linear combination:  $$ \\begin{align} {\\rm CL}(t) = {\\rm GI}(t) \\times {\\rm CL}{\\rm 1} (t) + (1-{\\rm GI}(t)) \\times {\\rm CL}{\\rm 0} (t), \\end{align} $$ where the two climate states  $$ \\begin{align} {\\rm CL}_0(t) &amp; = ( T_0^{\\rm mean}(t),T_0^{\\rm std}(t),P_0^{\\rm mean}(t), {\\rm LR}_0(t)), \\ {\\rm CL}_1(t) &amp; = ( T_1^{\\rm mean}(t),T_1^{\\rm std}(t),P_1^{\\rm mean}(t), {\\rm LR}_1(t)), \\end{align} $$ correspond to GI=\\(0\\) and GI=\\(1\\), respectively. Last, the GI function is built by linearly rescaling a climate proxy signal in such a way that GI is close to 1 at the ice maximum and close to 0 at the ice minimum. E.g., we may use the Antarctica EPICA temperature anomaly signal, which is available for the last 800'000 years.</p> <p>Note that the two climates \\({\\rm CL}_0\\) and  \\({\\rm CL}_1\\) are defined on 2 reference topographies different. Therefore, it is necessary to correct the temperature for a shift in elevation with a vertical laspe rate between the modelled ice surface elevation and the reference surface.</p> <p>[1] Jouvet, Guillaume, et al. \"Coupled climate-glacier modelling of the last glaciation in the Alps.\" Journal of Glaciology 69.278 (2023): 1956-1970.</p> <p>Contributors: G. Jouvet</p>"},{"location":"modules/processes/clim_glacialindex/#config-structure","title":"Config Structure","text":"<pre><code>clim_glacialindex:\n  update_freq: 100\n  climate_0_file: data/climate.nc\n  climate_1_file: data/climate1.nc\n  signal_file: data/GI.dat\n  vertical_lapse_rate_0: 6.0\n  vertical_lapse_rate_1: 5.74\n  temporal_resampling: 12\n</code></pre>"},{"location":"modules/processes/clim_glacialindex/#parameters","title":"Parameters","text":"<p>Here we store a table with</p> Name Type Units Description Default Value update_freq float $y$ Frequency at which to update the climate module 100 climate_0_file str ['dimensionless'] Climate file for glacial index 0 data/climate.nc climate_1_file str ['dimensionless'] Climate file for glacial index 1 data/climate1.nc signal_file str ['dimensionless'] Climate signal file for GI data/GI.dat vertical_lapse_rate_0 float $^\\circ$C km$^{-1}$ Vertical lapse rate for glacier index 0 6.0 vertical_lapse_rate_1 float $^\\circ$C km$^{-1}$ Vertical lapse rate for glacier index 1 5.74 temporal_resampling int $y^{-1}$ Temporal resampling, number of time steps per year 12 <p>--&gt;</p>"},{"location":"modules/processes/clim_glacialindex/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/clim_oggm/","title":"Module <code>clim_oggm</code>","text":"<p>The <code>clim_oggm</code> module processes monthly historical climate data from the GSWP3_W5E5 dataset obtained through the <code>oggm_shop</code> module. It generates monthly 2D raster fields that include corrected precipitation, mean temperature, and temperature variability. The process involves applying a multiplicative correction factor to precipitation (specified by the <code>prcp_fac</code> parameter) and a bias correction to temperature (specified by the <code>temp_bias</code> parameter). Temperature data is then extrapolated across the glacier surface using a reference height and a constant lapse rate, determined by the <code>temp_default_gradient</code> parameter. Conversely, precipitation and temperature variability data are distributed across the entire domain without additional corrections. The <code>oggm_shop</code> module provides all necessary calibrated parameters. These resultant fields are designed for use in surface mass balance or enthalpy modeling.</p> <p>In addition, this module can generate climate outside the time frame of available data. To that aim, we define a reference period with parameter <code>_ref_period</code> to pick randomly years within this interval (usually taken to be a climate-neutral period), and apply a biais in temperature and a scaling of precipitation. These parameters may be given in file (file name given in <code>file</code> parameter), which look like this (this example gives an linear increase of temperature of 4 degrees by the end of 2100 (with respect to the period 1960-1990):</p> <pre><code>time   delta_temp  prec_scal\n1900          0.0        1.0\n2020          0.0        1.0\n2100          4.0        1.0\n</code></pre> <p>If parameter <code>clim_trend_array</code> is set to empty list <code>[]</code>, then it will read the file <code>file</code>, otherwise it read the array <code>clim_trend_array</code> (which is here in fact a list of list).</p> <p>Contributors: Guillaume Jouvet, Fabien Maussion</p>"},{"location":"modules/processes/clim_oggm/#config-structure","title":"Config Structure","text":"<pre><code>clim_oggm:\n  update_freq: 1\n  file: file.txt\n  clim_trend_array:\n    - [\"time\", \"delta_temp\", \"prec_scal\"]\n    - [1900, 0.0, 1.0]\n    - [2020, 0.0, 1.0]\n  ref_period: [1960, 1990]\n  seed_par: 123\n</code></pre>"},{"location":"modules/processes/clim_oggm/#parameters","title":"Parameters","text":"<p>Here we store a table with</p> Name Type Units Description Default Value update_freq float $y$ Update the climate each X years 1 file string ['dimensionless'] Name of the input file for the climate outside the given datetime frame (time, delta_temp, prec_scaling) file.txt clim_trend_array list ['dimensionless'] Define climate trend outside available time window [['time', 'delta_temp', 'prec_scal'], [1900, 0.0, 1.0], [2020, 0.0, 1.0]] ref_period list ['dimensionless'] Define the reference period to pick year outside available time window [1960, 1990] seed_par integer ['dimensionless'] Seeding parameter to fix for picking randomly year in the ref period 123 <p>--&gt;</p>"},{"location":"modules/processes/clim_oggm/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/enthalpy/","title":"Module <code>enthalpy</code>","text":"<p>This IGM module models the ice enthalpy, which permits to jointly model the ice temperature, as well as the water content created when the temperature hits the pressure melting points, and therefore energy conservation, which is not the case when modelling the sole temperature variable. The model is described in (Aschwanden and al, JOG, 2012). </p> <p>Contributors: G. Jouvet</p> <p>This implementation is largely inspired from the one implemented in PISM. Other references that have helped are (Kleiner and al, TC, 2015) and (Wang and al, 2020).</p>"},{"location":"modules/processes/enthalpy/#config-structure","title":"Config Structure","text":"<pre><code>enthalpy:  \n  water_density: 1000.0\n  spy: 31556926.0\n  ki: 2.1\n  ci: 2009.0\n  Lh: 3.34e+5\n  KtdivKc: 1e-1\n  claus_clape: 7.9e-8\n  melt_temp: 273.15\n  ref_temp: 223.15\n  till_friction_angle: 30.0\n  till_friction_angle_bed_min: null\n  till_friction_angle_bed_max: null\n  till_friction_angle_phi_min: 15.0\n  till_friction_angle_phi_max: 45.0\n  uthreshold: 100.0\n  drain_rate: 0.001\n  till_wat_max: 2.0\n  drain_ice_column: True\n  default_bheatflx: 0.065\n  temperature_offset_air_to_ice: 0.0\n  tauc_min: 1.0e+5\n  tauc_max: 1.0e+10\n</code></pre>"},{"location":"modules/processes/enthalpy/#parameters","title":"Parameters","text":"Name Type Units Description Default Value water_density float $kg~m^{-3}$ Constant of the Water density 1000.0 spy float $s y^{-1}$ Number of seconds per years 31556926.0 ki float $W~m^{-1}~K^{-1}$ Conductivity of cold ice (Aschwanden and al, JOG, 2012) 2.1 ci float $W~s~kg^{-1}~K^{-1}$ Specific heat capacity of ice (Aschwanden and al, JOG, 2012) 2009.0 Lh float $W~s~kg^{-1} = E$ Latent heat of fusion (Aschwanden and al, JOG, 2012) 334000.0 KtdivKc float $\\frac{Kt}{Kc}$ [dimensionaless] Ratio of temp vs cold ice diffusivity (Aschwanden and al, JOG, 2012) 1e-1 claus_clape float $K~Pa^{-1}$ Clausius-Clapeyron constant (Aschwanden and al, JOG, 2012) 7.9e-08 melt_temp float $K$ Melting point at standard pressure (Aschwanden and al, JOG, 2012) 273.15 ref_temp float $K$ Reference temperature (Aschwanden and al, JOG, 2012) 223.15 till_friction_angle float $\\circ$ Till friction angle in the Mohr-Coulomb friction law 30.0 till_friction_angle_bed_min float $\\circ$ Minimum till friction angle at the bed None till_friction_angle_bed_max float $\\circ$ Maximum till friction angle at the bed None till_friction_angle_phi_min float $\\circ$ Minimum till friction angle phi 15.0 till_friction_angle_phi_max float $\\circ$ Maximum till friction angle phi 45.0 uthreshold float $\\frac{m}{y}$ Threshold velocity 100.0 drain_rate float $\\frac{m}{y}$ Drain rate at 1 mm/y (Bueler and Pelt, GMD, 2015) 0.001 till_wat_max float $m$ Maximum water till thickness (Bueler and Pelt, GMD, 2015) 2.0 drain_ice_column float $m$ Transform the water content beyond a threshold into water, drain it, and add it to basal melt rate True default_bheatflx float $W~m^{-2}$ Geothermal heat flux 0.065 temperature_offset_air_to_ice float $K$ Offset between the air temperature and the ice temperature 0.0 tauc_min float $Pa$ Lower bound for tauc 100000.0 tauc_max float $Pa$ Upper bound for tauc 10000000000.0"},{"location":"modules/processes/enthalpy/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/gflex/","title":"Module <code>gflex</code>","text":"<p>This IGM module permits to model the isostasy or upward motion of the lithosphere when loaded with thick ice, it uses the  gflex python module writen by Andy Wickert.</p> <p>Parameters are the update frequency <code>gflex_update_freq</code> and the Elastic thickness [m] (Te) <code>gflex_default_Te</code>.</p> <p>This module only runs on CPU, which may be an issue for treating very large arrays. On the other hand, we do not expect a frequent update, therefore, this module should not be overall too consuming.</p> <p>Contributors: J\u00fcrgen Mey</p>"},{"location":"modules/processes/gflex/#config-structure","title":"Config Structure","text":"<pre><code>gflex:\n  update_freq: 100.0\n  default_Te: 50000\n  dx: 1000\n  pad: False\n  quiet: True\n</code></pre>"},{"location":"modules/processes/gflex/#arguments","title":"Arguments","text":"Name Type Units Description Default Value update_freq float $y$ Update gflex each X years 100.0 default_Te float $m$ Default value for Te (Elastic thickness) if not given as ncdf file 50000 dx float $m$ Default resolution for computing isostasy 1000 pad boolean ['dimensionless'] Default padding option False quiet boolean ['dimensionless'] ??? True"},{"location":"modules/processes/gflex/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/glerosion/","title":"glerosion","text":"<p>Module <code>glerosion</code></p> <p>This IGM module implements change in basal topography (due to glacial erosion). The bedrock is updated (with a frequency provided by parameter <code>glerosion_update_freq years</code>) assuming a power erosion law, i.e. the erosion rate is proportional (parameter <code>glerosion_cst</code>) to a power (parameter <code>glerosion_exp</code>) of the sliding velocity magnitude. </p> <p>By default, we use the parameters from [1].</p> <p>[1] Herman, F. et al., Erosion by an Alpine glacier. Science 350, 193-195, 2015.</p> <p>Contributors: G. Jouvet</p>"},{"location":"modules/processes/glerosion/#config-structure","title":"Config Structure","text":"<pre><code>glerosion:\n  cst: 2.7e-7\n  exp: 2\n  update_freq: 1\n</code></pre>"},{"location":"modules/processes/glerosion/#arguments","title":"Arguments","text":"Name Type Units Description Default Value cst float ['dimensionless'] Erosion multiplicative factor, here taken from Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193\u2013195 (2015) 2.7e-07 exp float ['dimensionless'] Erosion exponent factor, here taken from Herman, F. et al. Eerosion by an Alpine glacier. Science 350, 193\u2013195 (2015) 2 update_freq float $y$ Update the erosion only each X years 1"},{"location":"modules/processes/glerosion/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/iceflow/","title":"Module <code>iceflow</code>","text":"<p>This IGM module models ice flow dynamics in 3D using a Convolutional Neural Network based on Physics Informed Neural Network as described in this paper. In more details, we train a CNN to minimise the energy associated with high-order ice flow equations within the time iterations of a glacier evolution model. As a result, our iflo_emulator is a computationally-efficient alternative to traditional solvers, it is capable to handle a variety of ice flow regimes and memorize previous solutions.</p> <p>This module permits to load, pretrain, retrain, and evaluate ice flow emulator. In addition, it can also be used for data assimilata / model inversion (former module <code>optimize</code>) setting this option: <pre><code>\"iflo_run_data_assimilation\": true,\n</code></pre> Check the documentation for using the <code>optimize</code> option below.</p> <p>It can also be used for pretraining an emulator (former module <code>pretraining</code>) setting option:  <pre><code>\"iflo_run_pretraining\": true,\n</code></pre> Check the documentation for using the <code>pretraining</code> option below.</p>"},{"location":"modules/processes/iceflow/#iceflow","title":"Iceflow","text":"<p>Pre-trained emulators are provided by defaults (parameter <code>iflo_emulator</code>). However, a from scratch iflo_emulator can be requested with <code>iflo_emulator=\"\"</code>. The most important parameters are:</p> <ul> <li>physical parameters </li> </ul> <pre><code>\"iflo_init_slidingco\": 0.045    # Init slid. coeff. ($Mpa y^{1/3} m^{-1/3}$)\n\"iflo_init_arrhenius\": 78.0     # Init Arrhenius cts ($Mpa^{-3} y^{-1}$)\n\"iflo_exp_glen\": 3              # Glen's exponent\n\"iflo_exp_weertman\":  3         # Weertman's sliding law exponent\n</code></pre> <ul> <li>related to the vertical discretization:</li> </ul> <pre><code>\"iflo_Nz\": 10                 # number of vertical layers\n\"iflo_vert_spacing\": 4.0     # 1.0 for equal vertical spacing, 4.0 otherwise\n</code></pre> <ul> <li>learning rate and frequency of retraining:</li> </ul> <pre><code>\"iflo_retrain_emulator_lr\": 0.00002 \n\"iflo_retrain_emulator_freq\": 5     \n</code></pre> <p>While this module was targeted for deep learning emulation, it important parameters for solving are :</p> <p>is possible to use the solver (<code>iflo_type='solved'</code>) instead of the default iflo_emulator (<code>iflo_type='emulated'</code>), or use the two together (<code>iflo_type='diagnostic'</code>) to assess the emaultor against the solver. Most important parameters for solving are :</p> <pre><code>\"iflo_solve_step_size\": 0.00002 \n\"iflo_solve_nbitmax\": 5     \n</code></pre> <p>One may choose between 2D arrhenius factor by changing parameters between <code>iflo_dim_arrhenius=2</code> or <code>iflo_dim_arrhenius=3</code> -- le later is necessary for the enthalpy model.</p> <p>When treating ery large arrays, retraining must be done sequentially patch-wise for memory reason. The size of the pathc is controlled by parameter <code>iflo_multiple_window_size=750</code>.</p> <p>Contributors: Guillaume Jouvet, Samuel Cook (global-modelling features in optimize)</p>"},{"location":"modules/processes/iceflow/#config-structure","title":"Config Structure","text":"<pre><code>iceflow:\n  iceflow:\n    run_pretraining: False\n    run_data_assimilation: False\n    type: \"emulated\"\n    pretrained_emulator: True\n    emulator: \"\"\n    init_slidingco: 0.0464\n    init_arrhenius: 78.0\n    enhancement_factor: 1.0\n    regu_glen: 1.0e-5\n    regu_weertman: 1.0e-10\n    exp_glen: 3.0\n    exp_weertman: 3.0\n    gravity_cst: 9.81\n    ice_density: 910.0\n    new_friction_param: True\n    save_model: False\n    Nz: 10\n    vert_spacing: 4.0\n    thr_ice_thk: 0.1\n    solve_step_size: 1.0\n    solve_nbitmax: 100\n    solve_stop_if_no_decrease: True\n    fieldin: [\"thk\", \"usurf\", \"arrhenius\", \"slidingco\", \"dX\"]\n    dim_arrhenius: 2\n    retrain_emulator_freq: 10\n    retrain_emulator_lr: 0.00002\n    retrain_emulator_lr_init: 0.0001\n    retrain_warm_up_it: -1.0e+10\n    retrain_emulator_nbit_init: 1\n    retrain_emulator_nbit: 1\n    retrain_emulator_framesizemax: 750\n    multiple_window_size: 0\n    force_max_velbar: 0.0\n    network: \"cnn\"\n    activation: \"LeakyReLU\"\n    nb_layers: 16\n    nb_blocks: 4\n    nb_out_filter: 32\n    conv_ker_size: 3\n    dropout_rate: 0\n    weight_initialization: \"glorot_uniform\"\n    exclude_borders: 0\n    cf_eswn: []\n    cf_cond: False\n    regu: 0.0\n    min_sr: 1.0e-20\n    max_sr: 1.0e+20\n    force_negative_gravitational_energy: False\n    optimizer_solver: 'Adam'\n    optimizer_lbfgs: False\n    optimizer_emulator: 'Adam'\n    optimizer_emulator_clipnorm: 1.0e+10\n    optimizer_emulator_epsilon: 1.0e-07\n    save_cost_emulator: \"\"\n    save_cost_solver: \"\"\n    output_directory: \"\"\n  optimize:\n    vars_to_save:\n        - \"usurf\"\n        - \"thk\"\n        - \"slidingco\"\n        - \"velsurf_mag\"\n        - \"velsurfobs_mag\"\n        - \"divflux\"\n        - \"icemask\"\n    init_zero_thk: False\n    regu_param_thk: 10.0\n    regu_param_slidingco: 1.0\n    regu_param_arrhenius: 10.0\n    regu_param_div: 1.0\n    smooth_anisotropy_factor: 0.2\n    smooth_anisotropy_factor_sl: 1.0\n    convexity_weight: 0.002\n    convexity_power: 1.3\n    usurfobs_std: 2.0\n    velsurfobs_std: 1.0\n    thkobs_std: 3.0\n    divfluxobs_std: 1.0\n    divflux_method: \"upwind\"\n    force_zero_sum_divflux: False\n    scaling_thk: 2.0\n    scaling_usurf: 0.5\n    scaling_slidingco: 0.0001\n    scaling_arrhenius: 0.1\n    control: [\"thk\"]\n    cost: [\"velsurf\", \"thk\", \"icemask\"]\n    nbitmin: 50\n    nbitmax: 500\n    step_size: 1.0\n    step_size_decay: 0.9\n    output_freq: 50\n    save_result_in_ncdf: \"geology-optimized.nc\"\n    plot2d_live: True\n    plot2d: True\n    save_iterat_in_ncdf: True\n    editor_plot2d: \"vs\"\n    uniformize_thkobs: True\n    sole_mask: False\n    retrain_iceflow_model: True\n    to_regularize: 'topg'\n    include_low_speed_term: False\n    infer_params: False\n    tidewater_glacier: False\n    vol_std: 1000.0\n    fix_opti_normalization_issue: False\n    velsurfobs_thr: 0.0\n    log_slidingco: False\n  pretraining:\n    data_dir: \"surflib3d_shape_100\"\n    batch_size: 1\n    freq_test: 20\n    train_iceflow_emulator_restart_lr: 2500\n    epochs: 5000\n    min_arrhenius: 5.0\n    max_arrhenius: 151.0\n    min_slidingco: 0.0\n    max_slidingco: 20000.0\n    min_coarsen: 0\n    max_coarsen: 2\n    soft_begining: 500\n</code></pre>"},{"location":"modules/processes/iceflow/#arguments","title":"Arguments","text":"Name Type Units Description Default Value Iceflow run_pretraining boolean ['dimensionless'] Run the pretraining scheme False run_data_assimilation boolean ['dimensionless'] Run the data assimilation scheme False type string ['dimensionless'] Type of iceflow: it can be emulated (default), solved, or in diagnostic mode to investigate the fidelity of the emulator towards the solver emulated pretrained_emulator boolean ['dimensionless'] Do we take a pretrained emulator or start from scratch? True emulator file path ['dimensionless'] Directory path of the deep-learning pretrained ice flow model, take from the library if empty string init_slidingco float $Mpa y^m m^{-m}$ Initial sliding coefficient slidingco 0.0464 init_arrhenius float $Mpa^{-n} y^{-1}$ Initial arrhenius factor arrhenius 78.0 enhancement_factor float ['dimensionless'] Enhancement factor multiplying the arrhenius factor 1.0 regu_glen float ['dimensionless'] Regularization parameter for Glen's flow law 1e-05 regu_weertman float ['dimensionless'] Regularization parameter for Weertman's sliding law 1e-10 exp_glen integer ['dimensionless'] Glen's flow law exponent 3.0 exp_weertman integer ['dimensionless'] Weertman's law exponent 3.0 gravity_cst float $m^2 s^{-1}$ Gravitational constant 9.81 ice_density float $kg m^{-3}$ Density of ice 910.0 new_friction_param boolean ['dimensionless'] Sliding coefficient (this describes slidingco differently with slidingco**-(1.0 / exp_weertman) instead of slidingco as before) True save_model boolean ['dimensionless'] Save the iceflow emulator at the end of the simulation False Nz integer ['dimensionless'] Number of grid points for the vertical discretization 10 vert_spacing float ['dimensionless'] Parameter controlling the discretization density to get more points near the bed than near the surface. 1.0 means equal vertical spacing. 4.0 thr_ice_thk float $m$ Threshold Ice thickness for computing strain rate 0.1 solve_step_size float ['dimensionless'] Step size for the optimizer used when solving Blatter-Pattyn in solver mode 1.0 solve_nbitmax integer ['dimensionless'] Maximum number of iterations for the optimizer used when solving Blatter-Pattyn in solver mode 100 solve_stop_if_no_decrease boolean ['dimensionless'] This permits to stop the solver if the energy does not decrease True fieldin list ['dimensionless'] Input fields of the iceflow emulator ['thk', 'usurf', 'arrhenius', 'slidingco', 'dX'] dim_arrhenius integer ['dimensionless'] Dimension of the arrhenius factor (horizontal 2D or 3D) 2 retrain_emulator_freq integer ['dimensionless'] Frequency at which the emulator is retrained, 0 means never, 1 means at each time step, 2 means every two time steps, etc. 10 retrain_emulator_lr float ['dimensionless'] Learning rate for the retraining of the emulator 2e-05 retrain_emulator_lr_init None ['dimensionless'] Initial Learning rate for the retraining of the emulator 0.0001 retrain_warm_up_it year ['dimensionless'] Warm-up nb of iteration allowing intense initial training -10000000000.0 retrain_emulator_nbit_init integer ['dimensionless'] Number of iterations done at the first time step for the retraining of the emulator 1 retrain_emulator_nbit integer ['dimensionless'] Number of iterations done at each time step for the retraining of the emulator 1 retrain_emulator_framesizemax integer ['dimensionless'] Size of the patch used for retraining the emulator, this is useful for large size arrays, otherwise the GPU memory can be overloaded 750 multiple_window_size integer ['dimensionless'] If a U-net, this forces window size to be a multiple of 2**N 0 force_max_velbar float $m y^{-1}$ This permits to artificially upper-bound velocities, active if &gt; 0 0.0 network string ['dimensionless'] This is the type of network, it can be cnn or unet cnn activation string ['dimensionless'] Activation function, it can be lrelu, relu, tanh, sigmoid, etc. LeakyReLU nb_layers integer ['dimensionless'] Number of layers in the CNN 16 nb_blocks integer ['dimensionless'] Number of block layers in the U-net 4 nb_out_filter integer ['dimensionless'] Number of output filters in the CNN 32 conv_ker_size integer ['dimensionless'] Size of the convolution kernel 3 dropout_rate float ['dimensionless'] Dropout rate in the CNN 0 weight_initialization string ['dimensionless'] glorot_uniform, he_normal, lecun_normal glorot_uniform exclude_borders integer ['dimensionless'] This is a quick fix of the border issue, otherwise the physics-informed emulator shows zero velocity at the border 0 cf_eswn list ['dimensionless'] This forces calving front at the border of the domain in the side given in the list [] cf_cond boolean ['dimensionless'] This forces calving front at the border of the domain in the side given in the list False regu float ['dimensionless'] This regularizes the energy forcing ice flow to be smooth in the horizontal direction 0.0 min_sr float $y^{-1}$ Minimum strain rate 1e-20 max_sr float $y^{-1}$ Maximum strain rate 1e+20 force_negative_gravitational_energy boolean ['dimensionless'] Force energy gravitational term to be negative False optimizer_solver string ['dimensionless'] Type of Optimizer for the solver Adam optimizer_lbfgs boolean ['dimensionless'] Select the L-BFGS optimizer instead of the Adam optimizer False optimizer_emulator string ['dimensionless'] Type of Optimizer for the emulator Adam optimizer_emulator_clipnorm float ['dimensionless'] If set, the gradient of each weight is individually clipped so that its norm is no higher than this value. 10000000000.0 optimizer_emulator_epsilon float ['dimensionless'] A small constant for numerical stability for the Adam optimizer 1e-07 save_cost_emulator string ['dimensionless'] save_cost_solver string ['dimensionless'] output_directory file path ['dimensionless'] Optimize vars_to_save list ['dimensionless'] List of variables to be recorded in the ncdf file ['usurf', 'thk', 'slidingco', 'velsurf_mag', 'velsurfobs_mag', 'divflux', 'icemask'] init_zero_thk boolean ['dimensionless'] Initialize the optimization with zero ice thickness False regu_param_thk float ['dimensionless'] Regularization weight for the ice thickness in the optimization 10.0 regu_param_slidingco float ['dimensionless'] Regularization weight for the slidingco field in the optimization 1.0 regu_param_arrhenius float ['dimensionless'] Regularization weight for the arrhenius field in the optimization 10.0 regu_param_div float ['dimensionless'] Regularization weight for the divergence field in the optimization 1.0 smooth_anisotropy_factor float ['dimensionless'] Smooth anisotropy factor for the ice thickness regularization in the optimization 0.2 smooth_anisotropy_factor_sl float ['dimensionless'] Smooth anisotropy factor for the slidingco regularization in the optimization 1.0 convexity_weight float ['dimensionless'] Convexity weight for the ice thickness regularization in the optimization 0.002 convexity_power float ['dimensionless'] Power b in the area-volume scaling V ~ a * A^b taken from 'An estimate of global glacier volume', A. Grinsted, TC, 2013 1.3 usurfobs_std float $m$ Confidence/STD of the top ice surface as input data for the optimization 2.0 velsurfobs_std float $m y^{-1}$ Confidence/STD of the surface ice velocities as input data for the optimization (if 0, velsurfobs_std field must be given) 1.0 thkobs_std float $m$ Confidence/STD of the ice thickness profiles (unless given) 3.0 divfluxobs_std float ??? Confidence/STD of the flux divergence as input data for the optimization (if 0, divfluxobs_std field must be given) 1.0 divflux_method string ['dimensionless'] Compute the divergence of the flux using the upwind or centered method upwind force_zero_sum_divflux boolean ['dimensionless'] Add a penalty to the cost function to force the sum of the divergence of the flux to be zero False scaling_thk float ['dimensionless'] Scaling factor for the ice thickness in the optimization, serves to adjust step-size of each control relative to each other 2.0 scaling_usurf float ['dimensionless'] Scaling factor for the ice thickness in the optimization, serves to adjust step-size of each control relative to each other 0.5 scaling_slidingco float ['dimensionless'] Scaling factor for the slidingco in the optimization, serves to adjust step-size of each control relative to each other 0.0001 scaling_arrhenius float ['dimensionless'] Scaling factor for the Arrhenius in the optimization, serves to adjust step-size of each control relative to each other 0.1 control list ['dimensionless'] List of optimized variables for the optimization ['thk'] cost list ['dimensionless'] List of cost components for the optimization ['velsurf', 'thk', 'icemask'] nbitmin integer ['dimensionless'] Min iterations for the optimization 50 nbitmax integer ['dimensionless'] Max iterations for the optimization 500 step_size float ['dimensionless'] Step size for the optimization 1.0 step_size_decay float ['dimensionless'] Decay step size parameter for the optimization 0.9 output_freq integer ['dimensionless'] Frequency of the output for the optimization 50 save_result_in_ncdf file path ['dimensionless'] Geology input file geology-optimized.nc plot2d_live boolean ['dimensionless'] plot2d_live_inversion True plot2d boolean ['dimensionless'] plot 2d inversion True save_iterat_in_ncdf boolean ['dimensionless'] Sve the iterations in a ncdf file True editor_plot2d string ['dimensionless'] optimized for VS code (vs) or spyder (sp) for live plot vs uniformize_thkobs boolean ['dimensionless'] uniformize the density of thkobs True sole_mask boolean ['dimensionless'] sole_mask False retrain_iceflow_model boolean ['dimensionless'] Retrain the iceflow model simultaneously? True to_regularize string ['dimensionless'] Field to regularize: topg or thk topg include_low_speed_term boolean ['dimensionless'] opti_include_low_speed_term False infer_params boolean ['dimensionless'] Infer slidingco and convexity weight from velocity observations False tidewater_glacier boolean ['dimensionless'] Is the glacier you're trying to infer parameters for a tidewater type? False vol_std float ??? Confidence/STD of the volume estimates from volume-area scaling 1000.0 fix_opti_normalization_issue boolean ['dimensionless'] Formerly, the oce was mixing reduce_mean and l2_loss leading to dependence to the resolution of the grid False velsurfobs_thr float $m y^{-1}$ Threshold for the surface ice velocities as input data for the optimization, anything below this value will be ignored 0.0 log_slidingco boolean ['dimensionless'] Optimize the log of the sliding coefficient instead of the slidingco itself False Pretraining data_dir str ['dimensionless'] Directory of the data of the glacier catalog surflib3d_shape_100 batch_size integer ['dimensionless'] Batch size 1 freq_test integer ['dimensionless'] Frequency of the test 20 train_iceflow_emulator_restart_lr integer ['dimensionless'] Restart frequency for the learning rate 2500 epochs integer ['dimensionless'] Number of epochs 5000 min_arrhenius float ['dimensionless'] Minimum Arrhenius factor 5.0 max_arrhenius float ??? Maximum Arrhenius factor 151.0 min_slidingco float ??? Minimum sliding coefficient 0.0 max_slidingco float ['dimensionless'] Maximum sliding coefficient 20000.0 min_coarsen integer ??? Minimum coarsening factor 0 max_coarsen integer ??? Maximum coarsening factor 2 soft_begining integer ['dimensionless'] soft_begining, if 0 explore all parameters between min and max, otherwise, only explore from this iteration while keeping mid-value for the first it. 500"},{"location":"modules/processes/iceflow/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/particles/","title":"Module <code>particles</code>","text":"<p>This IGM module implements a particle tracking routine, which computes trajectory of virtual particles advected by the ice flow. The specificity is that it runs in live time during the forward mdodel run and a large number of particles can be computed tanks to the parrallel implementation with TensorFlow. The routine includes particle seeding (by default in the accumulation area at regular intervals, but this can be customized), and tracking (advection by the velocity field in 3D). There is currently no strategy for removing particles, therefore, there is risk of overloading the memory when using this routine as it is for long time and/or with intense seeding.</p> <p>There are currently 2 implementations (switch with parameter <code>tracking_method</code>:</p> <ul> <li> <p><code>'simple'</code>: Horizontal and vertical directions are treated differently: i) In the horizontal plan, particles are advected with the horizontal velocity field (interpolated bi-linearly) ii) In the vertical direction, particles are tracked along the ice column scaled between 0 and 1 (0 at the bed, 1 at the top surface) with the  relative position along the ice column. Particles are always initialized at 1 relative height (assumed to be on the surface). The evolution of the particle within the ice column through time is computed according to the surface mass balance: the particle deepens when the surface mass balance is positive (the relative height decreases), and re-emerge when the surface mass balance is negative (the relative height increases).</p> </li> <li> <p><code>'3d'</code>: requires to activate module <code>vert_flow</code>, which computes the vertical velocity by integrating the divergence of the horizontal velocity. This permits in turn to perform 3D particle tracking.</p> </li> </ul> <p>For now, <code>tracking_method</code> is by default set to  <code>'simple'</code>, as the  <code>'3d'</code> method (and the dependence <code>vert_flow</code>) needs to further tested.</p> <p>Note that you my adapt the seeding to your need. You may keep the default seeding in the accumulation area setting the seeding frequency with <code>frequency_seeding</code> parameter and the seeding density <code>density_seeding</code> parameter. Alternatively, you may define your own seeding strategy (e.g. seeding close to rock walls/nunataks). To do so, you may redefine the function <code>seeding_particles()</code> in a file <code>particles.py</code> provided in the working directory (check the example aletsch-1880-2100). When excuted, <code>igm_run</code> will overide the original function <code>seeding_particles()</code> with the new user-defined one.</p> <p>The module needs horizontal velocities (state.U), as well as vertical speeds (state.W) that ice computed with the vert_flow module when <code>tracking_method</code> is set to <code>3d</code>. </p> <p>Note: in the code, positions of particles are recorded within a vector of lenght te number of traked particels state.xpos, state.ypos, state.zpos. Variable state.rhpos provide the relative height within the ice column (1 at the surface, 0 at the bed). At each time step, the weight of surface debris contains in each cell the 2D horizontal grid is computed, and stored in variable state.weight_particles.</p> <p>This IGM module writes particle time-position in csv files computed by module <code>particles</code>. The saving frequency is given by parameter <code>processes.time.save</code> defined in module <code>time</code>.</p> <p>The module also write the trajectories followed by particles: The data are stored in folder 'trajectory' (created if does not exist). Files 'traj-TIME.csv' reports the space-time position of the particles at time TIME with the following structure:</p> <pre><code>ID,  state.xpos,  state.ypos,  state.zpos, state.rhpos,  state.tpos, state.englt\nX,            X,           X,           X,           X,           X,           X,\nX,            X,           X,           X,           X,           X,           X,\nX,            X,           X,           X,           X,           X,           X,\n</code></pre> <p>providing in turn the particle ID, x,y,z positions, the relative height within the ice column, the seeding time, and the englacial time.</p> <p>Contributors: Guillaume Jouvet, Claire-Mathile St\u00fccki</p>"},{"location":"modules/processes/particles/#config-structure","title":"Config Structure","text":"<pre><code>particles:\n  tracking_method: 3d\n  frequency_seeding: 50\n  density_seeding: 0.2\n  tlast_seeding_init: -1.0e+5000\n  write_trajectories: True\n  add_topography: True\n</code></pre>"},{"location":"modules/processes/particles/#arguments","title":"Arguments","text":"Name Type Units Description Default Value tracking_method str ['dimensionless'] Method for tracking particles (3d or simple) 3d frequency_seeding float $y$ Frequency of seeding 50 density_seeding float ['dimensionless'] Density of seeding (1 means we seed all pixels, 0.2 means we seed each 5 grid cell, etc.) 0.2 tlast_seeding_init float $y$ Initialize the date of last seeding. If default value, the seeding will start the first year of the simulation. Changing this value allows to defer it -inf write_trajectories bool ['dimensionless'] Write the trajectories of the particles True add_topography bool ['dimensionless'] Add topg when writing particles True"},{"location":"modules/processes/particles/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/read_output/","title":"Module <code>read_output</code>","text":"<p>This IGM module permits to read an output NetCDF file produced previously and to run igm as if these quantities were shortly computed, this is mainly usefull for testing postprocessing module independently.</p> <p>Contributors: G. Jouvet</p>"},{"location":"modules/processes/read_output/#config-structure","title":"Config Structure","text":"<pre><code>read_output:\n  input_file: output.nc\n  crop: False\n  xmin: -1.0e+20\n  xmax: 1.0e+20\n  ymin: -1.0e+20\n  ymax: 1.0e+20\n</code></pre>"},{"location":"modules/processes/read_output/#arguments","title":"Arguments","text":"Name Type Units Description Default Value input_file str ['dimensionless'] NetCDF input data file output.nc crop bool ['dimensionless'] Crop the data from NetCDF file with given top/down/left/right bounds False xmin float $m$ X left coordinate for cropping the NetCDF data -1e+20 xmax float $m$ X right coordinate for cropping the NetCDF data 1e+20 ymin float $m$ Y bottom coordinate for cropping the NetCDF data -1e+20 ymax float $m$ Y top coordinate for cropping the NetCDF data 1e+20"},{"location":"modules/processes/read_output/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/rockflow/","title":"Module <code>rockflow</code>","text":"<p>This module extends the ice flow outside the glaciated area, by giving a constant speed and along-slope flow direction. This modules serves to track rock-like particles (with module <code>particles</code>) everywhere in ice-free and ice-filled areas, particles being either advected at constant steep (controlled by parameter <code>rock_flow_speed</code>) following the stepest gradient of the ice-free terrain in 2D, or by ice flow in 3D.</p> <p>Contributors: G. Jouvet</p>"},{"location":"modules/processes/rockflow/#config-structure","title":"Config Structure","text":"<pre><code>rockflow:\n  flow_speed: 1.0\n</code></pre>"},{"location":"modules/processes/rockflow/#arguments","title":"Arguments","text":"Name Type Units Description Default Value flow_speed float $m yr^{-1}$ Speed of rock flow along the slope 1.0"},{"location":"modules/processes/rockflow/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/smb_accpdd/","title":"Module <code>smb_accpdd</code>","text":"<p>Module <code>smb_accpdd</code> implements a combined accumulation / temperature-index model [Hock, 2003].  In this model, surface accumulation equals solid precipitation when the temperature is below a threshold and decreases linearly to zero in a transition zone. Conversely, the surface ablation is computed proportionally to the number of PDD, however, we track the snow layer depth, and different PDD proportionality factors or ice. The computation of the PDD using the expectation integration formulation (Calov and Greve, 2005), the computation of the snowpack, and the refereezing parameters are taken from PyPDD / PISM implementation.</p> <p>Input:  - state.precipitation [Unit: \\(kg m^{-2} y^{-1}\\) water eq]  - state.air_temp      [Unit: \\(^{\\circ}C\\)          ]</p> <p>Output:  -   state.smb           [Unit: m ice eq. / y]</p> <p>References:</p> <p>Hock R. (2003). Temperature index melt modelling in mountain areas, J. Hydrol.</p> <p>Calov and Greve (2005), A semi-analytical solution for the positive degree-day model with stochastic temperature variations, JOG.</p> <p>Contributors: G. Jouvet</p> <p>Note: It is a TensorFlow re-implementation similar to the one used in the aletsch-1880-2100 example but adapted to fit as closely as possible (thought it is not a strict fit) the Positive Degree Day model implemented in PyPDD (Seguinot, 2019) used for the Parralel Ice Sheet Model (PISM, Khroulev and the PISM Authors, 2020).</p> <p>Seguinot J. (2019). PyPDD: a positive degree day model for glacier surface mass balance (v0.3.1). Zenodo. https://doi.org/10.5281/zenodo.3467639</p> <p>Khroulev C. and the PISM Authors. PISM, a Parallel Ice Sheet Model v1.2: User\u2019s Manual. 2020. www.pism-docs.org</p>"},{"location":"modules/processes/smb_accpdd/#config-structure","title":"Config Structure","text":"<pre><code>smb_accpdd:\n  update_freq: 1\n  refreeze_factor: 0.6\n  thr_temp_snow: 0.0\n  thr_temp_rain: 2.0\n  melt_factor_snow: 1.095726596343\n  melt_factor_ice:  2.921937590248\n  shift_hydro_year: 0.75\n  ice_density: 910.0\n  wat_density: 1000.0\n</code></pre>"},{"location":"modules/processes/smb_accpdd/#arguments","title":"Arguments","text":"Name Type Units Description Default Value update_freq float $y$ Update the mass balance each X years 1 refreeze_factor float ['dimensionless'] Refreezing factor 0.6 thr_temp_snow float $^{\\circ}C$ Threshold temperature for solid precipitation 0.0 thr_temp_rain float $^{\\circ}C$ Threshold temperature for liquid precipitation 2.0 melt_factor_snow float $m yr^{-1} K^{-1}$ Degree-day factor for snow (ice eq.) 1.095726596343 melt_factor_ice float $m yr^{-1} K^{-1}$ Degree-day factor for ice (ice eq.) 2.921937590248 shift_hydro_year float ['dimensionless'] This serves to start Oct 1. the acc/melt computation 0.75 ice_density float $kg m^{-3}$ Density of ice for conversion of SMB into ice equivalent 910.0 wat_density float $kg m^{-3}$ Density of water 1000.0"},{"location":"modules/processes/smb_accpdd/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/smb_oggm/","title":"Module <code>smb_oggm</code>","text":"<p>Module <code>smb_oggm</code> implements the monthly temperature index model calibrated on geodetic MB data (Hugonnet, 2021) by OGGM. The yearly surface mass balance  is computed with </p> \\[ SMB = \\frac{\\rho_w}{\\rho_i}  \\sum_{i=1}^{12} \\left( P_i^{sol} - d_f \\max \\{ T_i - T_{melt}, 0 \\} \\right), \\] <p>where \\(P_i^{sol}\\) is the is the monthly solid precipitation, \\(T_i\\) is the monthly temperature and \\(T_{melt}\\) is the air temperature above which ice melt is assumed to occur (parameter <code>temp_melt</code>), \\(d_f\\) is the melt factor (parameter <code>melt_f</code>), and $\\frac{\\rho_w}{\\rho_i} $ is the ratio of water to ice density. Solid precipitation \\(P_i^{sol}\\) is computed out of precipitation and temperature such that it equals precipitation when the temperature is lower than a certain threshold (parameter <code>temp_all_solid</code>), zero above another threshold (parameter <code>temp_all_liq</code>), with a linear transition between the two. Module <code>oggm_shop</code> provides all calibrated parameters.</p> <p>Contributors: Guillaume Jouvet, Fabien Maussion</p>"},{"location":"modules/processes/smb_oggm/#config-structure","title":"Config Structure","text":"<pre><code>smb_oggm:\n  update_freq: 1\n  ice_density: 910.0\n  wat_density: 1000.0\n  melt_enhancer: 1\n</code></pre>"},{"location":"modules/processes/smb_oggm/#arguments","title":"Arguments","text":"Name Type Units Description Default Value update_freq float $y$ Update the mass balance each X years 1 ice_density float $kg m^{-3}$ Density of ice for conversion of SMB into ice equivalent 910.0 wat_density float $kg m^{-3}$ Density of water 1000.0 melt_enhancer float ['dimensionless'] Melt enhancer factor 1"},{"location":"modules/processes/smb_oggm/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/smb_simple/","title":"Module <code>smb_simple</code>","text":"<p>This IGM modules models a simple surface mass balance model parametrized by time-evolving ELA \\(z_{ELA}\\), ablation \\(\\beta_{abl}\\) and accumulation \\(\\beta_{acc}\\) gradients, and max accumulation \\(m_{acc}\\) parameters:</p> \\[SMB(z)=min(\\beta_{acc} (z-z_{ELA}),m_{acc})\\quad\\textrm{if}\\;z&gt;z_{ELA},$$ $$SMB(z)=\\beta_{abl} (z-z_{ELA})\\quad\\textrm{else}.\\] <p>These parameters may be given in file (file name given in <code>file</code> parameter), which look like this</p> <pre><code>time   gradabl  gradacc    ela   accmax\n1900     0.009    0.005   2800      2.0\n2000     0.009    0.005   2900      2.0\n2100     0.009    0.005   3300      2.0\n</code></pre> <p>or directly as parameter in the config <code>params.yaml</code> file:</p> <pre><code>smb_simple:\n   array: \n      - [\"time\", \"gradabl\", \"gradacc\", \"ela\", \"accmax\"]\n      - [ 1900,      0.009,     0.005,  2800,      2.0]\n      - [ 2000,      0.009,     0.005,  2900,      2.0]\n      - [ 2100,      0.009,     0.005,  3300,      2.0]\n</code></pre> <p>If parameter <code>array</code> is set to empty list <code>[]</code>, then it will read the file <code>file</code>, otherwise it read the array <code>array</code> (which is here in fact a list of list).</p> <p>The module will compute surface mass balance at a frequency given by parameter <code>update_freq</code> (default is 1 year), and interpolate linearly the 4 parameters in time.</p> <p>If one has provided in input an \"icemask\" field, then this module will compute negative surface mass balance (-10 m/y) in place where posstive surface mass balance outside the mask were originally computed. The goal here is to prevent against overflowing in neibourghing catchements.</p> <p>Contributors: G. Jouvet</p>"},{"location":"modules/processes/smb_simple/#config-structure","title":"Config Structure","text":"<pre><code>smb_simple:\n  update_freq: 1.0\n  file: param.txt\n  array: []\n</code></pre>"},{"location":"modules/processes/smb_simple/#arguments","title":"Arguments","text":"Name Type Units Description Default Value update_freq float $y$ Update the mass balance each X years 1.0 file string ['dimensionless'] Name of the input file for the simple mass balance model (time, gradabl, gradacc, ela, accmax) param.txt array list ['dimensionless'] Time dependent parameters for simple mass balance model (time, gradabl, gradacc, ela, accmax) []"},{"location":"modules/processes/smb_simple/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/texture/","title":"Module <code>texture</code>","text":"<p>This modules allows you to calculate ...</p> <p>Contributors: Brandon Finley</p>"},{"location":"modules/processes/texture/#config-structure","title":"Config Structure","text":"<pre><code>texture:\n  format: png\n  model_path: ${hydra.runtime.cwd}\n  verbosity: 30\n  divide_by_density: 1\n  resolution: -1\n</code></pre>"},{"location":"modules/processes/texture/#arguments","title":"Arguments","text":"Name Type Units Description Default Value format string ['dimensionless'] Format of the texture image (png, tif, or tiff) png model_path file path ['dimensionless'] Name of the folder for the texture model (tf format) ${hydra.runtime.cwd} verbosity integer ['dimensionless'] Python Logger verbosity level (10=DEBUG, 20=INFO, 30=WARNING, 40=ERROR, 50=CRITICAL) 30 divide_by_density boolean ['dimensionless'] This parameter solves an incompatibility (this option will be removed in the future) 1 resolution integer ['dimensionless'] This parameter solves an incompatibility (this option will be removed in the future) -1"},{"location":"modules/processes/texture/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/thk/","title":"Module <code>thk</code>","text":"<p>This IGM module solves the mass conservation of ice to update the thickness from ice flow (computed from module <code>iceflow</code>) and surface mass balance (given any module that update <code>smb</code>). The mass conservation equation is solved using an explicit first-order upwind finite-volume scheme on the 2D working grid. With this scheme mass of ice is allowed to move from cell to cell (where thickness and velocities are defined) from edge-defined fluxes (inferred from depth-averaged velocities, and ice thickness in upwind direction). The resulting scheme is mass conservative and parallelizable (because fully explicit). However, it is subject to a CFL condition. This means that the time step (defined in module <code>time</code>) is controlled by parameter parameter <code>processes.time.cfl</code>, which is the maximum number of cells crossed in one iteration (this parameter cannot exceed one), see the documentation of module <code>time</code>. A bit more details on the scheme are given in the following paper.</p> <p>Jouvet, G., Cordonnier, G., Kim, B., L\u00fcthi, M., Vieli, A., &amp; Aschwanden, A. (2022). Deep learning speeds up ice flow modelling by several orders of magnitude. Journal of Glaciology, 68(270), 651-664.</p> <p>Contributors: Guillaume Cordonnier, Guillaume Jouvet</p>"},{"location":"modules/processes/thk/#config-structure","title":"Config Structure","text":"<pre><code>thk:\n  slope_type: superbee\n  ratio_density: 0.910\n  default_sealevel: 0.0\n</code></pre>"},{"location":"modules/processes/thk/#arguments","title":"Arguments","text":"Name Type Units Description Default Value slope_type str ['dimensionless'] Type of slope limiter for the ice thickness equation (godunov or superbee) superbee ratio_density float ['dimensionless'] Density of ice divided by density of water 0.91 default_sealevel float $m$ Default sea level if not provided by the user 0.0"},{"location":"modules/processes/thk/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/time/","title":"Module <code>time</code>","text":"<p>This IGM modules computes time step such that i) it satisfy the CFL condition (controlled by parameter <code>cfl</code>) ii) it is lower than a given maximum time step (controlled by parameter <code>processes.time.step_max</code>) iii) it hits exactly given saving times (controlled by parameter <code>processes.time.save</code>). The module additionally updates the time \\(t\\) in addition to the time step.</p> <p>Indeed, for stability reasons of the transport scheme for the ice thickness evolution, the time step must respect a CFL condition, controlled by parameter <code>processes.time.cfl</code>, which is the maximum number of cells crossed in one iteration (this parameter cannot exceed one). By default, we take <code>processes.time.cfl</code> to 0.3. We additionally request time step to be upper-bounded by a user-defined parameter <code>processes.time.save</code> (default: 1 year).</p> <p>Among the parameters of this module <code>processes.time.start</code> and <code>processes.time.end</code> defines the simulation starting and ending times, while <code>processes.time.save</code> defines the frequency at which results must be saved (default: 10 years).</p> <p>A bit more details on the time step stability conditionsis given in the following paper.</p> <p>Jouvet, G., Cordonnier, G., Kim, B., L\u00fcthi, M., Vieli, A., &amp; Aschwanden, A. (2022). Deep learning speeds up ice flow modelling by several orders of magnitude. Journal of Glaciology, 68(270), 651-664.</p> <p>Contributors: G. Jouvet</p>"},{"location":"modules/processes/time/#config-structure","title":"Config Structure","text":"<pre><code>time:\n  start: 2000.0\n  end: 2100.0\n  save: 10.0\n  cfl: 0.3\n  step_max: 1.0\n</code></pre>"},{"location":"modules/processes/time/#arguments","title":"Arguments","text":"Name Type Units Description Default Value start float $y$ Start time of the simulation 2000.0 end float $y$ End time of the simulation 2100.0 save float $y$ Frequency of saving the simulation results 10.0 cfl float ['dimensionless'] CFL condition for time stepping 0.3 step_max float $y$ Maximum time step allowed 1.0"},{"location":"modules/processes/time/#example-usage","title":"Example Usage","text":""},{"location":"modules/processes/vert_flow/","title":"Macro Rendering Error","text":"<p>File: <code>modules/processes/vert_flow.md</code></p> <p>UndefinedError: 'dict object' has no attribute 'vert_flow'</p> <pre><code>Traceback (most recent call last):\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/mkdocs_macros/plugin.py\", line 688, in render\n    return md_template.render(**page_variables)\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 35, in top-level template code\n  File \"/home/gjouvet/anaconda3/envs/igm/lib/python3.10/site-packages/jinja2/environment.py\", line 471, in getitem\n    return obj[argument]\njinja2.exceptions.UndefinedError: 'dict object' has no attribute 'vert_flow'\n</code></pre>"}]}